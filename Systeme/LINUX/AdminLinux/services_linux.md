# LES SERVICE LINUX


## Bienvenue dans « Linux : Les services système »
Bonjour, je suis Yves Rougy, formateur dans le monde de GNU/linux depuis plus de 15 ans. Je vais vous parler des services systèmes dans les distributions GNU/linux modernes. Cette formation s’adresse aux administrateurs qui souhaitent mieux maitriser la gestion des services et le nouveau mécanisme systemd. Dans cette formation, nous nous plongerons dans le fonctionnement et les manipulations de systemd et nous verrons comment il gère les services, la configuration initiale de la machine, ou encore ce qui était connue sous le nom de « run level ». Nous parlerons également de la journalisation à l’aide de rsyslog et comment en tirer partie pour remonter les informations les plus pertinentes de nos systèmes. Vu que nous centraliserons la journalisation d’un ensemble de machines sur le même système, nous verrons l’importance de garder une synchronisation horaire entre ces machines. L’automatisation de tâche avec des ordonnances sur « cron » et « at » sera également de la partie, ainsi que quelques manipulations pour contrôler et surveiller les processus de notre machine. A l’issue de cette formation, vous serez capable de mieux gérer et de personnaliser les services fonctionnant dès le démarrage de vos systèmes. Commençons tout de suite cette formation. J’ai hâte de vous faire découvrir ces sujets.

## Aborder cette formation
Bonjour et bienvenue dans cette formation sur les services system. Dans ces vidéos, nous allons explorer le fonctionnement du logiciel systemd pour être capable de maitriser le lancement et l'arrêt des différents services de la machine. Nous verrons également à l'aide de systemd comment nous assurer qu'un daemon ou qu'un service que l'on a choisi est bien exécuté dès le boot de la machine. On enchainera avec les logs systèmes, avec la journalisation et on verra comment le protocole syslog et le logiciel rsyslog vont être capable de me sélectionner un certain nombre de messages des processus de la machine pour pouvoir les enregistrer dans des fichiers. On ira même un petit peu plus loin parce qu'on va aussi voir comment récupérer les logs d'une machine distante sur notre machine locale. Et enfin, devant cette très grande quantité de logs qu'on va récupérer, on verra des outils comme logwatch me permettant d'en extraire des données pertinentes. Nous verrons également comment nous assurer que nos machines sont toutes à la même heure et comment synchroniser nos machines à une horloge de référence. Ensuite, nous utiliserons ce qu'on va appeler l'ordonnanceur pour lancer des tâches régulières tous les premiers lundi du mois par exemple ou une fois par semaine, que ce soit pour les processus systèmes, que ce soit pour le fonctionnement de la machine ou que ce soit directement pour les utilisateurs. On en profitera pour voir un petit outil qui va me permettre de lancer une tâche ponctuelle à un moment donné. Et on finira avec quelques commandes qui vont me permettre de mieux connaître et de mieux voir ce qui se passe sur ma machine au niveau de la consommation des ressources CPU par exemple ou mémoire. Mais assez parlé, commençons tout de suite cette formation.

## Découvrir l'arborescence des processus
Alors on va entrer directement dans le vif du sujet en parlant de systemd. Systemd, qu’est-ce que c’est ? Systemd, c'est une implémentation du rôle de init dans le système Linux, le rôle de init, c’est le rôle d’être le tout premier processus de l’arborescence des processus. Pour voir ça, je peux faire la commande « pstree ». Alors la commande « pstree » elle va m’afficher, vous voyez que si je remonte un petit peu, elle va m’afficher une arborescence de processus en réalité, tout ça, ce sont tous des processus qui sont en train de tourner sur ma machine. Et sur ces processus-là, je vais voir que le tout premier, c’est systemd. Systemd qui a lancé « ModemManager », systemd qui a lancé « NetworkManager », systemd qui a lancé « VboxClient », c'est parce que je suis sur une machine qui est sous « VirtualBox », qui a lancé « abrt », « alsactl », « auditd », « avahi-daemon ». Bref, tous ceux-là ont été lancés à partir de systemd. Alors si jamais au lieu de faire « pstree », là il me montre bien que j’ai une arborescence de processus. Je fais la commande « ps –ef », alors je vais juste rajouter un « pipe », « less » derrière pour qu’il m’affiche ça page par page. Je vais voir tous les processus. Et donc mon systemd ici, c’est le premier de la liste. C'est le premier de la liste, son numéro de processus a le numéro 1 et il a été lancé par le processus qui a le numéro 0. Alors le processus qui a le numéro 0 n’existe pas, c’est le noyau, c'est-à-dire que la machine, quand elle a booté, le noyau a été chargé en mémoire et une fois que le noyau a été chargé en mémoire il a lancé le premier processus, en l’occurrence systemd. En parallèle, on voit que le noyau, il a lancé aussi un autre processus qui a le numéro 2. Alors là, c’est un petit peu trompeur parce qu’il ne s'agit pas d’un processus. Il s'agit d’un « thread » du noyau et qui s’appelle d’ailleurs « kthreadd ». Quant le noyau a besoin d’exécuter plusieurs fils d’exécution parallèle dans son propre espace de noyau, c'est-à-dire là où il y a les drivers, où il y a toutes ces choses-là, ce noyau va demander à « kthreadd » de créer le deuxième fil d’exécution, puis un troisième, puis un quatrième etc. Donc c’est une sorte de deuxième arborescence qui ne sont pas les processus qui sont extraits du noyau. Et on peut les identifier quand on regarde les processus parce que leur nom est encadré par des crochets, ici, on le voit bien, ce sont des crochets. Donc ils ne vont pas trop nous concerner. Par contre, si je regarde pour les processus, donc ici cette la colonne-là, c’est le numéro de processus, là c’est le numéro du processus qui l’a lancé. Donc ici, 2, 2, 2, 2, 2, ça ne nous intéresse pas, je fais barre d’espace, je descends, je vais aller plus bas parce que j'en cherche un en particulier qui se trouve ici, voilà. Le processus numéro 1043 a bien été lancé par le processus systemd, par systemd, par le rôle de « init ». Qu’est-ce que c’est que ce processus-là ? Il s’appelle « rsyslogd » et « rsyslogd », c’est le programme qui va s’occuper de gérer les logs, qui va s’occuper de gérer la journalisation. Et « rsyslogd » comme « cupsd » qui est ici, ce sont des processus qui sont lancés sous la forme de services. Donc le deuxième rôle à part être le premier processus de la machine ici, le deuxième rôle de systemd, ça va être de s’occuper de lancer tous les daemons, tous les services qui sont activés sur la machine. Ici, naturellement, nativement, sur ma machine, « rsyslogd » est activé pendant le boot du système et donc il est lancé par le boot du système, de la même manière que « cupsd », de la même manière que « crond », de la même manière que « gdm » qui m'a permis me connecter ici en mode graphique, de la même manière que « postfix » ici qui est le serveur de mail. J’avais « sshd » que j’ai loupé, voilà, qui est ici aussi. Tous ces processus-là sont des services qui démarrent automatiquement pendant le boot du système. Systemd, son rôle ça va être de choisir lesquels démarrent automatiquement et lesquels ne démarrent pas automatiquement lors du boot du système. Donc ça, c’est vraiment le deuxième rôle de mon systemd. Et pour ça, on a différentes commandes qui vont me permettre de gérer ces différents services et notamment la commande qui s'appelle la commande service. Et on va voir ça dans un instant.

## Démarrer et arrêter les services
Alors cette commande service qui sert donc à gérer les services comme son nom l'indique, elle est assez explicite dans son nom. C'est une vieille commande qui a été conçue à une époque où « init » avait basé le démarrage des différents services sur des « scripts shell » et le problème c'est que si on appelait directement le « script Shell » on passait au « script shell », l'environnement de l'utilisateur. Ce qui n'était pas toujours une bonne idée Pour éviter de le passer, on utilisait la commande service qui nettoyait l'environnement de l'utilisateur avant de lancer la commande. Elle est restée et suivant les différentes générations de « init » qu'on a eues, elle a continué à fonctionner et aujourd'hui finalement, elle va appeler la bonne commande. Ici, si je fais un « init » « rsyslog », « rsyslog status » pour en obtenir l'état, pour savoir dans quel état est mon « rsyslog », elle me dit quoi ? Elle me dit « Redirecting to systemctl ». En réalité, la commande qu'elle va appeler est la commande « systemctl ». Si j'avais été sur une Ubuntu pas la toute dernière génération qui elle travaille avec systemd mais les générations juste avant qui étaient avec un autre mécanisme que systemd, un mécanisme qui s'appelle « upstart », elle allait appeler la bonne commande qui est la commande « start » ou la commande « initctl ». Si ça avait été avec encore de plus vieux systèmes qui fonctionnent avec des scripts « shell », ma commande service aura appelé le script « /etc/init.d/rsyslog », le script qui permettait de gérer à l'époque le démarrage de « rsyslog ». Donc là on le voit, cette commande-là, elle est très pratique. Maintenant, malgré le fait qu'elle soit là, je vais me concentrer plutôt sur la commande « systemctl », puisque systemd aujourd'hui, c'est le système qui est présent sur les grandes distributions comme la RedHat, CentOS, comme la Debian, comme la « Ubuntu », la « Mint », toutes ces familles de distribution-là qui sont quand même les plus courantes. Alors ce « systemctl », alors je vais effacer ma page, je fais Ctrl + L pour effacer la page, si je fais un « systemctl status rsyslog », c'est la commande que je viens de taper, elle va me dire quoi ? Tout d'abord, là où elle est intéressante, c'est qu'elle essaie de me présenter pas mal de choses. Elle me met un petit feu vert, ici, le petit feu vert signifie quoi ? Le petit feu vert signifie tout simplement que le service, les feux sont au vert, ils fonctionnent bien. « Active », oui, il est actif, il est en train de tourner. Maintenant, j'ai d'autres choses intéressantes. Quand je demande le statut, il va me dire ce que fait ce service-là. Ici, « rsyslog » on voit, c'est le système qui gère la journalisation, le « System Logging Service », c'est lui qui gère le logging des activités du système. « Loaded », ça veut dire que lorsque systemd a démarré, il a trouvé une configuration associée à ce service-là. D'ailleurs, la configuration, elle est dans le fichier, le « usr/lib/systemd/system /rsyslog.service ». Attention, le fait qu'il y a une configuration ne veut pas dire d'une part que les processus sont installés ou d'autre part qu'elle va démarrer. Ça veut dire que si jamais les processus sont présents et qu'on lui dit de démarrer le service, la commande « systemctl » saura comment le démarrer. C'est la conf du : comment est-ce que je le démarre, quand est-ce que je le démarre, etc. Le point suivant, « enabled », ça signifie que dans le cas ici de mon « rsyslog », « rsyslog » sera activé dès le boot de la machine. Je peux très bien avoir des services comme par exemple le service « httpd » qui est installé sur ma machine, qui lui existe, que je peux démarrer mais qui n'est pas démarré automatiquement pendant le boot. Il faut que je le démarre manuellement. Alors on verra comment le passer en automatique mais l'idée du « enabled » c'est : est-ce que ce service-là a démarré automatiquement lors du boot et notamment : est-ce que dans la configuration par défaut quand il est installé, il est démarré automatiquement ou pas ? Est-ce que c'est une action de l'administrateur ou pas ? On le voit avec ce « vendor preset ». Si j'appelle le « systemctl status » de « httpd », je vais voir quoi ? Je vais voir que la configuration est chargée, elle me donne le nom du fichier de la configuration, qu'actuellement, il est « disabled » et puis que le « vendor preset », il est « disabled ». Et est-ce qu'il est actif ? J'ai un point noir, le point noir signifie qu'il n'est pas actif, il est inactif, « dead », il n'est pas en train de tourner et puis je peux voir qu'il a déjà été démarré, ça c'est encore une fois, un extrait des logs comme j'avais ici, un extrait des logs qui va me permettre de voir quelques éléments qui sont mis dans les logs, liés au démarrage ou à l'arrêt de ce service. On va voir à quoi ça sert dans un instant. Si je reprends ici donc le « Active », il me dit depuis quand est-ce qu'il a été démarré. Le « Main PID », c'est le processus qui a démarré. Donc là, c'est le processus numéro 1043, bon là, il n'y en a qu'un mais éventuellement, il peut en lancer d'autres. Et puis le « CGroup » attaché, le « CGroup », c'est une étiquette qu'on va lier à un processus et qui, quand ce processus-là va créer d'autres processus, aura également cette étiquette-là. Et puis là, le petit extrait des logs. Donc la même chose pour le web, pour le serveur web, c'est le server HTTP qui est là, le fichier de configuration, il est là, il est désactivé, par défaut, il est désactivé, actuellement il n'est pas en train de tourner, les documentations-là, j'ai deux lignes en plus qui me donnent les pages du manuel de la documentation Unix concernant ce serveur-là, ce service-là, le serveur httpd et puis un extrait des logs. Juste quelques éléments des logs, ce n'est pas en entier, c'est juste quelques éléments, si on utilise un « -l », on a les logs en entier. Alors, à quoi est-ce que ça, ça va servir ? Si je démarre donc « systemctl » et cette fois si je démarre, ça va être tout simplement la commande « start httpd » et ça va démarrer le service http. Si jamais je fais ça, il ne me dit rien mais s'il ne me dit rien à priori, c'est que ça s'est bien passé. Si je fais deux fois flèche haut pour revenir sur ma commande « status », je vais visualiser l'état du processus « httpd » et là je vais voir quoi ? Je vois que cette fois, il est passé au vert, qu'il est actif. J'ai la liste des processus qui ont été créés par le processus principal. Donc j'ai le 5045, 48, 49, 50, 51, 52, ils ont tous été créés là, ils sont tous visibles et avec mon petit extrait des logs, comme quoi ça fonctionne. En plus, ici pour le serveur web, j'ai quelques infos sur le trafic du serveur web. Alors, ce que je vais faire, c'est que je vais aller éditer la configuration de ce service-là et je vais mettre n'importe quoi au début pour générer une erreur. Donc je l'ai ouvert avec « vi », je fais un « O » majuscule pour insérer une ligne avant la ligne courante, j'écris « blabla », j'écris quelque chose, Échap, « :w » pour enregistrer, « :q », voilà. Ce que j'ai fait en faisant ça, c'est que j'ai rajouté une ligne qui dit blabla, qui ne veut rien dire, qui va générer une erreur forcément au début de la configuration du serveur web. Mon idée, c'est qu'est-ce qui se passe avec « systemctl » cette fois quand je le redémarre ? Donc je vais faire « systemctl restart httpd » et là, qu'est-ce qui se passe ? Il va tenter de le redémarrer et il m'affiche un message d'erreur. Donc du coup, il me propose de regarder avec le « status » pour voir ce qui s'est passé, donc je vais rappeler, la commande status qui est un petit peu plus haut, voilà elle est là et là cette fois « Insert service » qui a tenté de démarrer et qui n'a pas réussi à démarrer, le feu est au rouge pour attirer mon attention. Donc là, est-ce qu'il est actif ? Il a échoué, ça veut dire qu'on a tenté de le démarrer et ça n'a pas fonctionné. Il me donne les processus qui ont généré l'erreur et j'ai un petit extrait, dit « log », quand il a tenté de démarrer le service. Et d'ailleurs, ce qui est intéressant, c'est que je peux voir ici : « Syntax error on line 1 » du fichier « Invalid command » blabla. Donc il est capable, dans le cas du httpd, ça peut être différent suivant les autres services, de me dire où se trouve l'erreur. Je n’ai pas besoin de creuser dans les logs à la main, pour savoir où se trouvent les erreurs. Donc, je vais aller corriger le problème. Donc « vi » voilà, je le rappelle, je fais « dd » pour effacer la ligne courante, « :w », « :q » et ça devrait fonctionner. Si je fais un « restart », voilà, « restart », il ne me dit rien. Si je rappelle le statut, cette fois il tourne. Mais si ma machine démarre, il est toujours désactivé. Si jamais je veux activer ce service-là, lors du boot de la machine, j'aurais juste à faire « systemctl enable httpd ». Donc là, qu'est-ce qu'il fait ? Il crée des liens symboliques, il fait ce qu'il faut mais si je rappelle le statut, il va me dire quoi ? Il va me dire que cette fois, il est « enabled ». Si jamais j'arrête la machine et que je la redémarre, lors du démarrage de la machine, le serveur web sera démarré. Donc on le voit, cette commande « systemctl » est extrêmement pratique pour gérer les services qui fonctionnent pour les démarrer, pour les arrêter, pour les activer lors du boot ou les désactiver lors du boot puisque si je veux à nouveau la désactiver, ce n'est pas « enable » que je vais faire, c'est le « disable » tout simplement et si jamais je fais le statut, je suis repassé à « disabled ». Donc voilà un petit peu pour cette commande « systemctl » qui permet de gérer les services en cours sur la machine.

## Comprendre les processus targets et runlevels
Cette commande systemctl qu'on vient de voir, c’est une commande qui va me permettre de démarrer, d’arrêter ou éventuellement d’activer ou désactiver des services lors du démarrage mais elle va beaucoup plus loin que ça. C’est la commande qui permet de gérer systemd et de gérer toutes les opérations qui sont réalisées par systemd. Cette commande « systemctl » va me permettre, comme on l’a vu précédemment, de configurer rsyslog pour que rsyslog soit démarré lors du « boot-up ». Si je regarde le statut de rsyslog, mon statut c’est qu'il est « enabled ». Lors du boot, rsyslog a démarré. Mais du coup, la question se pose, quand a-t-il démarré pendant la phase de boot car il va se passer des choses pendant le boot, notamment je suis sur un système qui a plusieurs partitions, donc il va falloir monter ces différentes partitions. Est-ce que c’est monté avant de démarrer mon rsyslog ou est-ce que c’est monté après ? Ça serait bien de le démarrer après car si les logs sont dans une partition à part, la partition doit être montée pour pouvoir y accéder. Même chose si je tape « top », je vais voir que j’ai du « swap » qui est activé. Est-ce que mon rsyslog démarre avant l’activation du « swap » ou après l’activation du « swap » ? C’est encore une fois le rôle de systemd de s’occuper de ça. Et donc pendant les phases de démarrage, il y a plusieurs opérations qui vont s’enchainer et ces différentes opérations, notamment les premières opérations, sont très visibles, monter les systèmes de fichier, mettre en place le « swap », elles devront avoir lieu dans un certain ordre. Et pour ça, il y a différentes, ce qu’on appelait des « target » qui sont définis avec systemd. Alors si je fais « ctrl + L » pour effacer la page, je peux afficher pour systemd les différentes « target » qui sont configurés. Alors pour ça, je fais « systemctl », je vais faire un « list-units ». Alors une « target » c’est une unité, c'est-à-dire que systemd va gérer des « target ». Il va également gérer des services, comme on l’a vu. Le service, c’est une autre forme d’unité. Moi, ceux qui vont m’intéresser ici c’est « type=target ». Donc je ne vais afficher que les « target ». Et si je regarde ce qu’il y a, j’ai différentes choses qui sont en plus commentées, c'est-à-dire que le « basic.target » qui est ici, c’est le « system basic », alors « system basic » on n’aura pas l’interface graphique, on aura très peu de choses. Le « cryptsetup », c’est lui qui va permettre de gérer les volumes chiffrés. Le « getty.target », c’est lui qui va me permettre d’avoir des consoles avec lesquelles je pourrai me connecter en mode texte. Le « graphical.target », c’est ce qui va me permettre d’avoir l’interface graphique. Chaque élément correspond en réalité à un certain nombre de choses qui devront se passer sur la machine. Et une des toutes premières opérations qui a lieu, c’est le « sysinit.target ». Le « sysinit.target », une fois qu’il est obtenu, il pourra enchainer avec autre chose. Et lui le « sysinit.target », il ne sera obtenu, que quand on aura monté le système de fichier local et qu’on aura activé le « swap » puisque ce sont les opérations qui ont lieu dedans. On le voit, à chaque fois que mon système va démarrer, il a un certain nombre de points qu’il va devoir atteindre et à partir de ce point-là, il ira éventuellement vers un autre point s’il n’a pas terminé son démarrage. Typiquement, une fois qu’on a fini le « sysinit », peut-être qu’on peut passer en « multi-user.target ». Il va activer le fait qu’on puisse se connecter sur la machine. Et le « mulit-user.target » sur ma machine, qui a une interface graphique, parce que j’ai une souris, j’ai des menus et elle, elle va appeler le « graphical.target ». Donc on le voit, c’est vraiment différentes étapes, qui vont avoir lieu les unes après les autres. Alors, si je m’intéresse à la configuration de ce « sysinit.target », je vais appeler la commande « systemctl » et je vais lui demander avec la commande « cat », enfin là c’est une option « cat », de m’afficher la configuration, le fichier de configuration de « sysinit.target ». Et si je fais ça, il me l’affiche, voilà. Il me dit, c’est un fichier qui fait partie de systemd, il me dit où il est, je pourrais ne pas savoir où il est, je peux laisser systemd gérer l’endroit où il est. Il me dit que comme « unité », c’est l’initialisation du système. Il y a de la documentation avec la page du manuel qui est concerné. Il ne pourra pas tourner en même temps que les « target » « emergency.service emergency.target ». Les « unity » « emergency.service » et « emergency.target » Le « wants », ça veut dire que ça, ce sont des dépendances pour pouvoir activer le « sysinit ». Donc le « sysinit », si je dis : tu passes en « sysinit », il va regarder si le local est fait, si le target est fait. S’il n’a pas été fait, il va le faire, ensuite il va regarder le « swap.target », s’il n’a pas été fait, il va le faire. Et « after », ça aura lieu automatiquement quand celui-là aura été appelé, quand celui-là aura été appelé, quand celui-là aura été appelé ou quand celui-là aura été appelé. Alors je propose qu’on aille voir, par exemple, le « swap.target ». Donc je vais rappeler la même commande, « systemctl cat » et cette fois ce que je vais faire, c’est d’ailleurs, je vais mettre le « swap.target », et ici je vais avoir quoi ? « Description=swap », il ne me dit pas grand-chose. Le but ici, c’est d’activer le « swap ». Donc c’est juste une étiquette, si vous voulez, ces « target »-là, ce sont des étiquettes et on va rattacher des services, des opérations à ces différentes étiquettes. Le « swap target », par exemple, si je dis : tu vas en « swap target », il y a des actions qui sont associées au « swap target » et qui vont permettre du coup d’activer le « swap », en l’occurrence. Et cette configuration « swap.target », le rôle, l’action qu’elle va réaliser, c’est qu’elle va rechercher les unités de type « .swap ». Donc si je liste les unités cette fois, pas les « target », mais les unités de type « swap », je n'ai qu’une seule qui apparait, alors il m’affiche un « less » donc je peux faire « q ». Il n'y a qu’une seule qui apparait, qui en réalité, correspond, alors ici on voit, il a un nom un petit peu étrange, c’est juste que c’est le périphérique en passant par son « UUID » et «l’UUID» il est précisé ici, correspond à ce fichier-là, c’est tout simplement la partition qui a cette « UUID »-là, enfin, celui qui est marqué ici, et la partition qui a cet « UUID » là, c’est la partition de « swap » et donc du coup il va activer le « swap » de cette partition-là. Ce qu’il faut vraiment comprendre ici avec ces différentes « target », c’est que les « target », c’est un élément un petit peu plus fin que ce qu’on avait avec les « run level » avec les niveaux d’exécution qu’on avait autrefois sur les distributions. On disait le niveau 1 c’est le mode mon utilisateur, le niveau 5 c’est le mode graphique multiutilisateurs. Là, on passe vraiment par des petites étapes intermédiaires, on peut toutes les lister. Donc là, si je reliste mes « target », ce sont toutes les « target » qui ont été atteintes pour atteindre l’état dans lequel je suis en ce moment, c'est-à-dire qu’il est passé par toutes celles-là et il a commencé à avoir une « target » de destination. À priori, c’est ma « graphical.target ». Et en regardant les prérequis pour les « graphical.target », on est redescendu à des dépendances, des dépendances de dépendance, des dépendances de dépendance de dépendance, etc. jusqu’à arriver aux premières opérations réalisées, puis ensuite toutes les faire dans le bon ordre. Je peux d’ailleurs ajouter une option « --all » ici derrière mon « type=target », pour dire je ne veux pas que les « target » qui ont été atteintes pour atteindre l’état dans lequel je suis maintenant, mais toutes celles qui existent et qui sont définies. On voit qu’il y en a quelques-unes de plus, il n’y a pas énormément en plus mais il y a quelques-unes de plus. Il y en a une dont il ne trouve pas le fichier de conf, le « syslog.target », il ne le trouve pas tout simplement parce qu’on n'utilise plus syslog sur ces machines-là, on utilise rsyslog qui est un successeur à syslog. Alors on peut voir celles qui sont actives, celles qu’on avait dans l’écran d’avant. Les inactives, c’est quoi ? C’est la synchronisation du temps qui n’est pas active. C’est le mode « rescue » qui n’est pas actif. Oui on est en mode multiutilisateurs, on n'est pas en mode « rescue ». Le « Port Mapper » n’a pas été démarré. On n'est pas en train d’arrêter la machine. On a tout un ensemble de choses comme ça qui ne sont pas actives, qu’on peut voir ici. Donc systemd lui, il va démarrer le système en regardant quelle est la cible qu’il doit atteindre et quelles sont les dépendances liées à cette cible-là, comme on vient de le voir.

## Lancer les services avec systemd
Mon systemd gère les services. On a vu ça tout à l’heure. On était capable de démarrer, d’arrêter des services, systemd s’occupe de ça. Et la commande qui permet de demander à systemd de faire ces opérations-là, c’est la commande « systemctl ». Là je vais creuser un petit peu plus la gestion des services avec systemd, en utilisant « systemctl ». Pour commencer ça, je vais rappeler ce qu’on a vu tout à l’heure déjà le statut, l’état de rsyslog. Donc « systemctl status rsyslog » et là il m’affiche l’état du service rsyslog, je vois qu’il est actif, etc. J’ai déjà présenté ça. Je ne vais pas revenir dessus mais c'est quelque chose qu’on a déjà vue. Par contre, je vais m’intéresser à ce fichier-là. Ce fichier-là, qu’est-ce que ça va être ? Ce fichier-là, son rôle ça va être de décrire pour systemd comment démarrer rsyslog, qu’est-ce que c’est comme service, quand est-ce qu’il doit être démarré, etc. En réalité ce fichier-là, c’est vraiment le cœur de la configuration de rsyslog pour systemd. Je peux aller le regarder à la main ce fichier-là. Je peux me passer d’aller le regarder à la main, je peux demander à systemd de me l’afficher. Pour ça, je vais utiliser la commande « systemctl », « systemctl cat rsyslog.service ». Dans ce cas-là, mon « systemctl » va m’afficher le contenu du fichier. Alors là je sais où il est. Si je ne savais pas où il était, il m’aurait trouvé quand même puisque c’est lui qui le gère tout seul. Attention, quand la machine démarre, ces fichiers-là ils sont vus, ils sont chargés en mémoire. Pour le moment, il les prend en mémoire. J’ai plusieurs parties dans ce fichier-là. J’ai une partie « unit » qui va me décrire l’unité en question. C’est un service, une unité de type service. Comment est-ce qu’on va gérer ce service-là ? Ça va être décrit ici et dans quel cas l’installer là. Il ne faut pas l'avoir installé comme copie des fichiers, il faut voir l’installer sur à quel moment le lancer, l’installer dans le fonctionnement du système. Si je regarde ça en détail, « unit », je vais avoir une description qui va être donnée. La description, c’est ce qui va être marquée quand je demande le statut à cet endroit-là, c'est-à-dire que si jamais je change les mots « System Login Service » en autre chose, j’aurais autre chose qui sera affichée là quand le système aura remis à jour sa configuration. Ensuite ici, vous voyez qu’il y a un paramètre point-virgule qui commente la ligne d’après. Et j’ai un « after » qui va me définir quand est-ce que cette unité-là devra être appelée ou pourra être appelée. Ça sera après la « target network ». Cette partie unit, elle est présente dans toutes les configurations de toutes les unités de systemd et elle va donner en quelque sorte les métadonnées. Quand est-ce que ça s’exécute ou quand est-ce que c’est appelé ? Et puis la description de cet élément-là. Je passe au suivant, qui est « service ». Cette partie « service », cette ligne « service » ici, elle ne concerne que les unités de type « service », comme leur nom l’indique, que les unités de type « service » et là-dedans, on va dire ce qu’on doit faire au niveau des unités de type « service ». Les différentes options de service vont être les suivantes : le « type=notify », ici, va me préciser que le service, quand il aura démarré, il va prévenir, enfin il faudra prévenir systemd qu’on a démarré. Et quand il va être lancé, pendant que je vais demander à ce que rsyslog se lance, systemd n’attendra que rsyslog soit lancé avant de passer à la suite. Ensuite, j’ai quoi ? J’ai « EnvironmentFile » avec le nom d’un fichier. Et en plus le nom du fichier, il est précédé d’un tiré. Ici ça veut dire que je vais avoir un fichier texte qui va contenir l’environnement dans lequel le service va démarrer. Alors l’environnement dans lequel le service va démarrer, ça veut dire qu’on va décrire les variables d’environnement qui seront initialisés pour le démarrage du service. Le fait qu’il y a un petit tiré devant, il signifie que si jamais ça échoue, là en l’occurrence si jamais le fichier n’existe pas, on ne fait pas échouer le lancement du service, l’unité ne va pas échouer à ce moment-là. Le « ExecStart », qui est la ligne d’après correspond à la ligne de commande à exécuter pour lancer ce service-là. Ici, donc c’est « /usr/sbin/rsyslogd » en passant l’option « -n » puis en passant le contenu de la variable « SYSLOGD_OPTIONS ». cette variable-là pourrait tout à fait être initialisée à partir du contenu du fichier précédent puisqu’on va d’abord charger l’environnement avant d’exécuter cette commande-là. Puis après, on a quelques autres informations, comme le « Restart=on-failure ». Ça veut dire que si jamais il y a un échec, que le programme plante, à ce moment-là on le redémarrera. Le « Umask », ça lui permet de définir les droits des fichiers par défaut quand il va créer des fichiers. Et puis le « StandardOutput=null », ça veut tout simplement dire qu’il n’affichera rien sur le terminal qui le lancerait, il coupe sa sortie standard. Donc là, voilà c’est la deuxième partie et au final cette dernière partie, cette partie « Install », va me préciser également comment ce service-là va être démarré. C’est une section qui est facultative. Ça permet juste de savoir dans quel ordre je vais la démarrer, à quel moment, etc. Ici, on le voit, on a comme directive « WantedBy », qui veut dire « Voulu par », « multi-user.target ». Ça veut dire que si jamais je vais dans le « multi-user.target », il sera nécessaire d’avoir déjà lancé ce service-là. Ça permet de savoir les dépendances de qui correspond à quoi avec ce fichier-là. C’est un fichier qui est relativement simple. Il y en a qui sont un petit peu complexes et il y en a qu’on va pouvoir personnaliser, notamment on va permettre de voir dans les plus complexes et dans la personnalisation qu’on pourra faire, comment aller plus loin au niveau de ces services. Pour ça, je vais effacer la page, donc Ctrl + L et pour ça je vais faire un « systemctl status ssh ». « Ssh.service » ne peut pas être trouvé, ça doit être « sshd », voilà. « Sshd », c’est le « daemon ssh ». Donc là mon « sshd », il est décrit ici et on voit évidemment que j’ai également un fichier qui est là. L’intérêt de voir ce fichier « sshd », c’est qu’il a plus de dépendance que le fichier rsyslog, donc on va un peu plus loin avec. Je vais faire mon « systemctl cat sshd », je ne vais pas l’oublier cette fois, « .service ». Et ici je vois mon fichier, donc j’ai pareil, une description qui est donnée ici. Les pages de documentation sont mentionnées ici. J’ai du « after » et du « want ». Ça veut dire quoi ? Le « after » veut dire qu’il ne démarrera que quand on aura déjà atteint la « target network » et quand le « sshd keygen » aura été exécuté. Et on le rajoute ici, on a besoin que celui-là soit exécuté. C’est vraiment un point qui est important, parce que ça veut dire que « sshd » ne démarrera pas si « sshd keygen » n’a pas démarré. On a une dépendance forte ici. Pour information, le « sshd keygen » va regarder si les clés du serveur pour le service « ssh » ont déjà été créées ou pas. Si elles n’ont pas été créées, il va les créer avant de démarrer le service, sinon le service ne démarrerait pas. Et si elles ont été créées, il laissera le service démarrer. Si elles ne sont pas démarrées, ils les créent. Si elles ne sont pas créées, il va les créer. Si elles sont déjà créées, il va démarrer le service normalement. Le service est de type « forking ». Le type « forking », ça veut dire quoi ? Ça veut dire que le processus, il va être lancé, puis il va être autonome. Si jamais le processus lanceur s’arrête, le processus lancé va continuer à fonctionner, c'est-à-dire qu’il va fonctionner en tâche de fond, il n’a pas besoin de son père. En gros systemd va lancer « sshd » et puis va passer à la suite. Le « PIDFile » ici, c’est le numéro du processus qui aura été créé quand on lance ce service, qui va être enregistré dans ce fichier-là, de la même manière, on a un fichier d’environnement, de la même manière que pour rsyslog. Le « ExecStart », ça me donne la ligne de commande à lancer pour exécuter ce service et ici j’ai un « ExecReload ». Le « ExecReload » qu’est-ce qu’il va faire ? Le « ExecReload », c’est la commande qu’on va lancer dans le cas où on va faire un « systemctl reload sshd ». Le « reload » n’est pas un « restart ». Dans le cas où on fait « restart », on fait « stop » et un « start ». Ici le « reload » qu’est-ce qu’il va faire ? Il va lancer cette commande-là qui aura pour effet de demander à sshd de relire sa configuration et de prendre en compte cette nouvelle configuration. Le « killmode=process », ça veut dire que si jamais on veut « killer » le service, si on veut le détruire de la mémoire, il faudra tout simplement tuer le processus. Le « restart=on-failure », ça on l’a vu précédemment, ça fonctionne pareil. Et le « RestartSec », il va préciser le temps à attendre avant de redémarrer le service, c'est-à-dire que si jamais le service redémarre après un « failure », il va faire une pause de 42 secondes avant de le redémarrer. Et puis dans le « Install », on le voit qu’il sera à mettre en place dans la cible « multi-user.target ». Ça nous permet de comprendre un petit peu les services, comment ils fonctionnent, comment ils sont configurés. On ne passe pas par des scripts, c’est vraiment systemd qui à partir de ces informations-là, va activer ou désactiver ces services. Ce qui va être intéressant de voir, c'est maintenant, comment est-ce qu’on va pouvoir personnaliser tout ça.

## Comprendre le principe des démons
On va s’intéresser cette fois au daemon. On va s’intéresser au service qui tourne en tâche de fond. On a vu, il y a un certain nombre de services qui tournent déjà en tâche de fond : on a le serveur « ssh » qui tourne, on peut avoir le serveur web qui tourne. Si je fais la commande « ps -ef » et puis je vais faire un petit « less » derrière. Je vois tout pleins de programmes qui fonctionnent sur la machine. La différence qu’on va avoir entre les daemons, programmes qui sont des daemons et ceux qui ne sont pas des daemons, c’est que d’une manière traditionnelle, les programmes que je vais manipuler, on en voit un ici, la commande « ps », c’est un programme que je manipule quand je tape ma commande « ps -ef », il m’affiche le résultat du fonctionnement de la commande « ps » à l’écran. « À l’écran », ça veut dire quoi ? C’est sur le terminal. Mon processus « ps » quand il va fonctionner, lui, il est connecté à deux sorties : il a la sortie standard qu'on voit ici, qui est associée à l’écran et il a également une sortie d’erreurs. Si je passe des options stupides comme celle-là, il m’affiche le résultat sur l’écran également, donc la sortie d’erreurs est également connectée à l’écran. Le processus « ps » qui est un processus interactif, ce n’est pas un daemon, ce n’est pas un service, il est connecté sur le terminal, en sortie. Et ça va un petit peu plus loin puisque ma commande « vi » par exemple, qui est un éditeur, mon « vi », lui, il est connecté en sortie sur le terminal, on le voit, il affiche des choses sur le terminal. Mais si jamais je passe en mode insertion, en faisant « a » ou « i », tout ce que je tape va être envoyé au programme « vi ». Ça veut dire quoi ? Ça veut dire que « vi » va aussi recevoir des informations sur l’entrée via clavier. Et donc le programme « vi » est connecté au clavier, via ce qu’on va appeler l’entrée standard. La plupart des processus qu’on va avoir sont donc associés aux terminaux et quand ils veulent s’exprimer, quand ils ont quelque chose à dire, ils vont le dire sur le terminal. Quand on veut communiquer, nous, avec eux, comment est-ce qu’on va communiquer avec eux ? On va communiquer avec eux en passant par le terminal. Et ça, c’est le cas de la plupart des processus qu’on va avoir sur la machine. Je vais quitter mon « vi » ici. Je vais faire « :q », Échap, « :q! ». Pour les processus qui ne sont pas rattachés aux terminaux. Quels processus ne sont pas rattachés aux terminaux ? Ce sont tous les processus qui ont été lancés sous forme de service pendant le boot de la machine. On a « sshd » qui a été lancé comme ça, on a « rsyslog » qui a été lancé comme ça, je vois ici à l’écran, j’ai le serveur web httpd qui a été lancé comme ça. La caractéristique de ceux-là, c’est qu’ils ont été lancés pour le moment pendant le boot de la machine par systemd ou par un outil système si vous avez un autre système. Ils ne sont pas lancés depuis un terminal. Ils sont complètement détachés du terminal. Ils fonctionnent derrière, en tâche de fond. Mais ça, ça a un impact qui est direct, qui est que quand ils ont quelque chose à dire, il n’y a pas de terminal sur lequel ils vont pouvoir le dire. Ils ne sont pas rattachés à un terminal, donc ils n’ont pas de sortie connectée à un terminal. De la même manière, quand on va vouloir communiquer avec eux, pour communiquer avec eux, on ne pourra pas passer par le clavier comme je le fais ici dans mon « shell ». Mon « shell », il écoute ce que je dis sur le clavier. Il écoute ce que je dis sur le clavier parce que le clavier fait partie du terminal, et donc reçoit sur son entrée standard les informations du terminal. Mon httpd ne reçoit rien provenant du clavier. Il va falloir avoir des mécanismes quand on va vouloir dialoguer avec le service pour pouvoir d’une part savoir ce qu’il a à dire, et d’autre part être capable de lui envoyer des informations. Et c’est là la caractéristique de ce qu’on va appeler un daemon sous Unix. C’est beaucoup plus général que juste sous Linux. Un daemon sous Unix, c’est un programme qui tourne en tâche de fond, complètement déconnecté des terminaux de la machine. Il n’est pas rattaché à un terminal. Et ce daemon, il a pour rôle, d’offrir un service à d’autres processus ou à des utilisateurs locaux ou à des utilisateurs distants. Et son fonctionnement est géré par le mécanisme « unit » et géré par, soit par des scripts de démarrage, soit ici dans notre cas, des programmes lancés par systemd. La caractéristique du daemon, c’est qu’il est détaché du terminal, il est géré par systemd et il fonctionne en tâche de fond. On ne le voit pas au niveau de nos terminaux. On ne peut pas interagir avec eux au niveau de nos terminaux.

## Découvrir le protocole syslog
Nos daemons qui tournent en arrière-plan dans la machine, qui ne sont pas rattachés à un terminal, ils n’ont donc nulle part où s’exprimer. C’est là qu’intervient syslog. Syslog, en réalité, va me représenter deux choses. Il va tout d’abord me représenter un protocole qui est un protocole de discussion entre des processus et syslog, entre des processus en arrière-plan, des daemons et syslog. C’est un protocole qui est également un protocole réseau. On le mettra en place un petit peu plus tard, on va voir que c’est également un protocole réseau. Alors, ce syslog, qu’est-ce qu’il va faire ? Il va recevoir les messages de la part des daemons. Il va recevoir énormément de messages parce que dès qu’un daemons a quelque chose à dire, il va envoyer son message à syslog. En quelque sorte, c’est le « psy » des daemons, ce qui est quand même un gros boulot. Alors, les messages ne vont pas être envoyés n’importe comment. Les messages vont être envoyés avec deux informations qui leur sont associées, la catégorie du message et la gravité du message. Alors ces deux informations-là, on ne va pas mettre ce qu’on souhaite. C’est normalisé justement dans ce protocole. Et dans les catégories, on va rencontrer les suivantes. Il y a la catégorie « kern » qui va être attachée à tous les messages qui sont envoyés par le noyau. La catégorie « user » qui va être attachée à tous les messages de la part des processus du nom d’utilisateur, de l’espace utilisateur. On a la catégorie « mail » qu’on attachera aux messages liés au système de mail. Attention, on ne pourra mettre qu’une catégorie. Ça ne peut pas être à la fois « user » et « mail ». Un message est reçu, il vient d’un endroit, il vient d’une catégorie, d’une seule provenance. On va avoir « daemons » qui est pour les daemons système, c’est un petit peu le fourre-tout celui-là. On va rencontrer plein de monde qui vient de daemons. « Auth » et « auth-priv », quant à eux, vont envoyer des messages. Ils vont être associés aux messages liés à l’authentification et aux autorisations sur la machine. « Syslog », c’est quand syslog veut s’envoyer quelque chose parce qu’il joue également le rôle d’une réception des messages quand il a quelque chose à se dire. « Lpr » qui correspond au mécanisme d’impression du système. « News », c’est le protocole NNTP, c’est lié au protocole NNTP, c’est lié au système de « news » qui existe sous UNIX. « Uucp », c’est lié au protocole UUCP qui est le « Unix to Unix Copy Protocol » qui est un vieux protocole qu’on utilisait essentiellement quand on n’avait pas de connexion internet permanente, quand on était connecté par modem. On a « ftp » qui est lié, vous vous en doutez, au protocole FTP. « Cron » qui est lié à la « cron tab » et ensuite on a « local0 » à « local7 ». Il y aura quelques autres qui sont utilisés mais ils ne sont pas directement manipulables. Donc quand un message est reçu, le message provient forcément d’une de ces catégories et en plus de ces catégories, il y a un niveau de gravité. Alors, à quoi ça va servir cette catégorie ? Avant de parler du niveau de gravité, cette catégorie va servir à ce que quand un message est reçu, le syslog va pouvoir choisir ce qu’il va faire du message en fonction de la catégorie et également en fonction de la gravité. Et la gravité, il y en a huit niveaux. Ici ils sont classés par ordre décroissant d’importance. Le message le plus important étant le « emerg », c’est le message d’urgence. Attention, la gravité « emerg » sera associée à une catégorie et va indiquer que le système est sur le point de s’arrêter, de planter. Quand il y a une gravité « emerg » qui arrive, très souvent elle est associée à la catégorie « kern ». Ensuite on a les messages de type « alert ». Les messages de type « alert » sont des messages très graves, qui nécessitent une intervention sur la machine. On a « crit » pour l’erreur critique, erreur critique pour le système ou pour la catégorie. On a l’erreur de fonctionnement, c’est une erreur qui n’est pas critique. Et tout ce qui va être en dessous, ça ne va pas correspondre à des erreurs mais à des informations de type avertissement ou « warning », attention, attirer notre attention sur un point, on nous prévient qu’il y a un « warning » quelque part. « Notice » qui correspond à un événement remarquable, qui s’est passé, il faut le savoir, il faut le lire. Les messages de type informatif et les messages de « debug ». Et avec tout ça, syslog va recevoir des messages avec une catégorie et une gravité. Et il va être capable de classer les messages qu’il reçoit en fonction de cette catégorie et de cette gravité. Là, je suis sur une configuration de syslog et dans cette configuration de syslog, je vais voir comment est-ce qu’on va justement organiser ces informations-là. Mon syslog reçoit toutes les informations. Il reçoit toutes les informations, à chaque message il a une catégorie, une gravité qui lui est associée. Qu’est-ce qu’il va en faire ? Il va regarder si dans sa configuration, il a un motif qui correspond au message qui est reçu. Par exemple ici, j’ai « * .info » qui est un motif qui va en réalité faire correspondre à tous les messages de catégorie « info », et attention, message de catégorie « info » et supérieure. Quand on marque une gravité, c’est à partir de cette gravité qu’on définit le message. Donc là, tous les messages de catégorie « info » et supérieure, ça fait beaucoup de messages, vont arriver et vont correspondre à ce motif-là. Et donc lui, il va vouloir faire une action qui va être décrite sur la deuxième partie de la ligne, je vais décrire ça dans un instant. Mais pourquoi je vais décrire ça dans un instant ? Parce que mon motif n’est pas terminé, j’ai d’autres éléments sur la ligne. Ici, j’ai un point-virgule qui va me dire que j’ai un autre élément qui va me préciser le motif : « mail.none ». Alors « none » en anglais, veut dire « aucun » et par conséquent ici, quand j’ai « * .info;mail.none », ça veut dire : tous les messages de la catégorie « info » ou supérieure sauf les messages de la catégorie « mail » puisque je ne veux aucun message de la catégorie « mail ». Et je continue : aucun message de la catégorie « authpriv » et aucun message de la catégorie « cron ». Les messages « mail », « authpriv » et « cron » vont être enregistrés ailleurs. C’est pour cela qu’on ne les met pas dans celui-là. Donc ça c’est le premier cas. On peut également avoir ici, tous les messages de la catégorie « authpriv ». Alors, on pourrait faire ça autrement. À la place d’écrire ça, je pourrais tout à fait écrire, je vais changer là, pour le montrer, je pourrais tout à fait écrire : « authpriv.debug ». Si j’écris « authpriv.debug », ça va marcher aussi puisque l’importance du message, c’est à partir de cette importance-là qu’on affichera des messages. Tous les messages « debug » et supérieurs seront alors capturés par ce motif-là. Vu qu’il n’y a pas plus bas que « debug », ça sera tous les messages. Ensuite, qu’est-ce qu’on va faire de ces messages ? Ces messages, on va les envoyer ici dans un fichier dont le nom est écrit ici. Ici dans cet exemple précis, j’envoie les messages de l’importance « debug » et supérieure de la catégorie « authpriv », tous les messages « authpriv », dans le fichier « /var/log/secure », tout simplement. Une petite remarque, c’est qu’ici, tous les messages de la catégorie « mail » sont envoyés dans « -/var/log/maillog ». Le « - » ici a une signification précise, qui veut dire que quand un message est reçu et est envoyé pour être écrit dans le fichier « /var/log/maillog », il est écrit normalement dans le fichier. Par conséquent, vous devez vous douter que quand il n’y a pas de « - », ce n’est pas écrit normalement. Effectivement, c’est écrit anormalement, anormalement dans le sens où dès qu’un message est écrit dans le fichier, les buffers qui sont en mémoire, qui permettent de mémoriser les accès disque, sont vidés sur le disque, c'est-à-dire qu’on essaie d’écrire de manière synchrone sur le disque. C’est quelque chose qui est important puisqu’on a des messages qui peuvent prévenir que la machine va planter et si jamais on attend que les buffers se vident, peut-être qu’ils se videront que quand la machine aura planté. Donc pour les logs système comme celui-là par exemple, « /var/log/messages », on fait le choix d’écrire de manière synchrone sur la machine, c’est beaucoup plus lent, c’est beaucoup plus intensif pour la machine, ce qui fait que pour le mail par exemple, on met bien le petit « - » devant pour dire : « si jamais ça peut attendre un petit peu pour être écrit dans le disque, ça attendra un petit peu, ça ne posera aucun souci. » Donc ça, c’est vraiment le fonctionnement de base de syslog. Il reçoit les messages de tous les processus, de tous les daemons. Il en fait une petite sélection et à partir de cette sélection qui est basée sur des motifs ici, il va écrire les messages dans différents fichiers. Alors, il peut envoyer ça également sur un serveur distant. Il peut également envoyer ça sur le terminal d’un utilisateur connecté ou sur tous les terminaux connectés sur la machine

## Connaître les limites de syslog et de rsyslog
Alors notre syslog est la pierre angulaire de la gestion des logs sous Linux. C’est à la fois un protocole et un logiciel on l’a vu mais le logiciel syslog commence à dater un petit peu, il a plein de limitations qu’on va vouloir contourner en utilisant d’autres outils comme par exemple rsyslog qui en est une version plus moderne. La version rsyslog va me permettre d’aller plus loin, notamment dans la sélection des messages d’une part et d’autre part dans qu’est-ce que je vais faire de ces messages. Si je regarde la configuration de rsyslog, la configuration de rsyslog va me décrire tout d’abord un certain nombre de modules que je vais utiliser. Je reviendrais dessus un petit peu après, notamment pour pouvoir recevoir des messages en UDP ou en TCP, qui sont les deux grands protocoles réseaux utilisés. Je descends un petit peu, il me donne également d’autres éléments, c’est son répertoire de travail, la manière dont on représente l'horodatage puisqu’il y a plein de manières de représenter un horodatage. Est-ce que je dis : jour, mois, année, heure, minute, seconde ou le nombre de secondes depuis le démarrage de la machine ou le nombre de secondes depuis le 1er janvier 1970 ou année, mois, jour, heure, minute, seconde, dixième de seconde ? Il y a plein de manières de le faire, c’est défini ici. Tout ce qui commence par un # est commenté. Celui-là, on ne l’a pas commenté parce que par défaut, c’est une écriture synchrone qui serait extrêmement longue. On a la possibilité de rajouter des configurations à partir du contenu d’un répertoire, c'est-à-dire que si je fais un fichier qui s’appelle « toto.conf » dans le répertoire « /etc/rsyslog.d », il sera inclus dans la configuration. Il y a d’autres éléments qui sont dedans, qui ne sont pas les plus importants. Ce qui va m’intéresser, c’est cette partie-là qui est la partie qui ressemble à la partie syslog traditionnelle. Et dans cette partie-là, j’ai des motifs qui sont basés uniquement sur la provenance du message dans la catégorie du message et la gravité. C’est la seule manière que j’ai de pouvoir définir un message. Donc à partir de ce moment-là, je voudrais récupérer des messages, non pas en fonction de la provenance mais en fonction du contenu du message. Je veux récupérer tous les messages qui contiennent le mot-clé « exemple » et que je mette ça dans un fichier qui s’appelle « exemple ». Je vais le faire ici, je vais rajouter une règle à la fin, où je vais dire quoi ? Je vais utiliser des extensions qui ne sont pas dans syslog, qui n’existent que dans rsyslog et notamment, au lieu de donner « catégorie.gravité », je vais mettre un « : ». C’est dire que c’est un truc qui est étendu, ça n’est pas dans le syslog traditionnel. Et la manière de choisir ce que je vais envoyer dans mon fichier, ça va être en fonction du contenu du message et non pas de sa provenance. Donc c’est ce « :msg » qui permet d’avoir ça. Et qu’est-ce que je vais avoir ? Je vais faire un « contains, » et la chaine de caractères. Par exemple, je veux que ça contienne le mot-clé « exemple ». Et qu’est-ce que je fais de ce fichier-là ? Je vais l’envoyer dans « /var/log/Logexemple » dans mon exemple. En faisant cette ligne-là, au lieu de faire une sélection par rapport à la provenance du message, la catégorie du message et la gravité du message, quelle que soit la provenance, quelle que soit la gravité, la sélection du message se fera si jamais il y a la chaine de caractères « exemple » dans le message lui-même. On va essayer ça, je fais Échap, « :w » pour enregistrer, « :q » pour quitter. Ce qu’on va faire, c’est qu’on va redémarrer : « systemctl restart rsyslog ». On va redémarrer rsyslog pour que cette configuration qu’on vient de faire, cette fois, elle soit prise en compte. Ce n’est pas parce qu’on a changé le fichier de configuration que rsyslog l’a immédiatement pris en compte. Il faut redémarrer syslog pour qu’il la prenne en compte. Et maintenant, ce que je vais faire, c’est que je vais envoyer un message à syslog contenant le mot-clé « exemple ». Pour ça, je vais utiliser la commande « logger ». Elle me permet d’envoyer un message au format avec le protocole syslog au daemon syslog qui tourne dans la machine et là, donc en l’occurrence, à mon rsyslog. Pour ça, je fais « logger –p » pour préciser la provenance du message parce que tous les messages de syslog ont une catégorie et une gravité. Donc je vais les préciser, « user.info » par exemple. Et puis derrière, je vais mettre mon message : « Voici un message d’exemple ». Et quand je fais ça, si je fais un « cat /var/log/logexemple », le fichier a été créé et il contient bien mon message. Si jamais j’envoie un autre message, un message autre, voilà : « Voici un message autre », ce message autre n’ira pas dans « /var/log/logexemple » parce qu’il ne contient pas le mot-clé « exemple ». Si je reviens sur mon fichier de configuration, je vais descendre, je peux préciser autre chose que « la catégorie.la gravité », comme ici, ce qu’il y a dans le message. Je peux faire d’autres choses, des choses qui sont assez intéressantes, je peux faire une expression régulière. Voilà, ça c’est une expression régulière que j’ai faite. Ça va être uniquement les messages dont le dernier mot de la ligne est « exemple ». S’il y a un point après l’« exemple », ça ne marchera pas. On peut mettre une expression régulière à cet endroit-là, par rapport au contenu du message. On peut faire une sélection par rapport au nom de la machine avec la directive « :host ». Il y a beaucoup de choses qu’on peut faire. Donc là, c’est pour vous montrer l’avancée que donne rsyslog par rapport à syslog au niveau de la sélection du message. Et maintenant, c’est également intéressant par rapport à la destination du message puisque je peux créer des fichiers qui seront des fichiers dynamiques, c'est-à-dire dont le nom n’est pas statique. Ici, le nom est statique, il s’appelle toujours « logexemple ». Je peux, avec rsyslog, mettre des noms dynamiques. Ce que je vais faire, ça va être de définir tout d’abord un « template ». Je vais essayer de le faire proprement parce que je vais le remettre avant les règles, voilà. Je vais définir ici un « template » : « $template ». Et mon « template », je vais définir un fichier dynamique. Je vais l’appeler « DynamicFile, » et cette fois je vais donner le nom dynamique que je veux avoir, en l’occurrence « /var/log/% » pour dire que je vais appeler une variable, « $DAY » pour dire que c’est le jour d’aujourd’hui, « %.log ». Le fichier, son nom sera un « numéro.log », le numéro correspondant au numéro du jour. Alors, comme une fois que j’ai fait ça, je vais reprendre cette ligne-là. Donc je vais faire un copier-coller tout simplement. Pour ça, je fais « Y + Y » pour copier et « P » pour coller. Donc ça va être avec le même motif. Et dans le même motif, au lieu ici d’avoir le nom du fichier, à la place, je mets un « ? ». Ça veut dire que je vais appeler le « template » que j’ai défini auparavant. Donc là, je vais appeler quel « template » ? Le « template DynamicFile ». Et en faisant ça, normalement le système, quand un message va aller dans « messages », il va également, puisque c’est le même motif, aller dans le « template DynamicFile » dans « /var/log/ », le numéro du jour, « .log ». On va essayer ça. Je fais « Échap », « : w » pour enregistrer, « :q » pour quitter, j’efface la page, je fais un « systemctl restart rsyslog ». Et ce que je vais faire maintenant, c’est que je vais faire un « logger -p user.info » pour avoir un message qui va aller dedans et le message, ça va être « hello ». Cette fois, si je fais un « ls -l /var/log », qu’est-ce que je vais voir apparaitre ? J’ai tout plein de choses qui apparaissent et j’ai ce fameux fichier, on le voit. On est le 31 mars, le fichier s’appelle « 31.log » et si je regarde ce qu’il y a dedans : « cat /var/log/31.log », j’ai bien les messages de redémarrage de syslog qui ont été attrapés dans le fichier « messages » mais également le message « hello » que j’avais. Donc ça me permet de voir que rsyslog est capable de faire des sélections de messages plus précises et également avoir des destinations de message beaucoup plus fines que ce qu’on faisait avec syslog.

## Configurer le réseau avec rsyslog
Alors maintenant qu’on a vu comment fonctionnait syslog, qu’on a vu comment rsyslog nous permettait d’aller un petit peu plus loin à la fois en termes de sélection des messages qu’on va vouloir conserver et en termes d’action à réaliser, la destination de ces messages qu’on souhaite conserver, on va aller encore plus loin et on va regarder comment récupérer les logs d’une machine distante en quasi-temps réel. Pour ça, j’ai un petit peu changé mon bureau là, j’ai toujours ma machine sur laquelle je suis toujours connecté. Et à côté, ici, en jaune pour qu’on puisse bien le distinguer, je suis connecté sur une machine distante qui est une Debian d’ailleurs, qui n’est pas une CentOS comme la machine sur laquelle je suis et qui possède également rsyslog. Et je vais souhaiter que depuis cette machine-là, qui est la Debian, les logs soient envoyés à ma machine sur laquelle je suis depuis tout à l’heure. Alors pour ça, il y a plusieurs opérations à réaliser. La première opération à réaliser est de s’assurer qu’il n’y a pas de « firewall » sur le réseau, qui bloquerait la transmission entre la machine distante et la machine locale. Ici, je suis dans une machine virtuelle, je n’ai pas de « firewall » d’activé. Donc je ne vais pas m’en préoccuper mais c’est la première chose à laquelle il faut que vous fassiez attention. Une fois que vous êtes sûr que les paquets vont circuler entre les deux machines, qu’est-ce qu’on va faire ? Ce qu’on va réaliser maintenant, ça va être d’activer sur ma machine locale la réception des messages. Pour ça, je vais aller dans le fichier « /etc/rsyslog.conf », toujours le même fichier de configuration. Et si on regarde ici, au début du fichier, dans les modules, je suis sur ces quelques lignes-là, j’ai la réception de syslog avec le protocole UDP et la réception de syslog avec le protocole TCP. Alors, je vais désactiver les deux, je vais d’abord faire l’un, puis l’autre. Mais les deux fonctionnent. L’intérêt de l’UDP, c’est que si énormément de messages arrivent sur ma machine, il n’arrivera peut-être pas à tous les enregistrer, auquel cas ils vont perdre quelques-uns. Oui, ça peut être un intérêt parce que si j’ai le même comportement en TCP, que trop de messages arrivent sur la machine pour que je puisse les enregistrer, le danger qui peut se présenter, c’est que ça va saturer la file d’attente d’entrée des messages et dans ce cas-là, la couche réseau, notamment pour syslog, peut planter et on ne reçoit plus rien. Dans le cas d’UDP, les paquets ne sont pas reçus, ils sont éjectés, ils sont éliminés et puis voilà. D’un autre côté, TCP peut être très intéressant quand je ne risque pas de saturer l’entrée de rsyslog, il va être très intéressant dans le sens où sur du TCP, on peut mettre du TLS, c'est-à-dire qu’on va pouvoir faire du chiffrement et éviter que les messages circulent en clair sur le réseau, ce qui est quand même un énorme avantage. Alors, pour le moment je vais commencer simplement avec l’UDP. Donc je vais désactiver le module et le port d’écoute. En faisant ça, j’autorise mon rsyslog à écouter sur le réseau les paquets qui arriveraient de la part de n’importe quelle destination. « :w » pour enregistrer, « :q » et je redémarre mon rsyslog, « systemctl restart rsyslog », voilà. Et donc là, je n’ai rien d’autre à faire sur cette machine locale. Maintenant je vais aller sur la machine distante. Voilà, je suis sur la machine distante et cette fois je vais éditer le fichier « /etc/rsyslog.conf », c’est bien le même fichier. Il est présenté d’une façon un petit peu différente. On retrouve bien quand même ici nos modules. Ceux-là, je ne vais pas les toucher puisque je n’envoie rien vers la machine distante. Je veux que ça soit elle qui m’envoie des données. Si je descends, je descends, je descends, voilà, les règles sont là. Il y a d’autres règles avec d’autres formats mais ce que je vais faire, c’est que je vais dire que les messages « * .info », je vais les envoyer à ma machine locale. Là, je suis sur la machine distante, je vais les envoyer à la machine locale. Comment je vais faire ça ? Je vais utiliser le caractère @ qui veut dire que les messages sont envoyés à distance. Et je vais donner l’adresse IP de la machine sur laquelle les envoyer. L’adresse IP de ma machine, je vais aller le vérifier ici. Ça va être « ip addr show » pour que je voie l’adresse IP. Et mon adresse IP est marquée ici, c’est la « 10.0.2.4 ». Voilà, je retourne à distance et je vais dire ici que c’est la « 10.0.2.4 », Échap, « :w », « :q ». Et si je redémarre à l’aide de « systemctl restart rsyslog », « tail -f /var/log/syslog », c’est l’équivalent du fichier « messages » sur l’autre distribution. Je m’assure que tout a bien redémarré : « Started Logging Service », il fait d’autres choses, ok. Ça a l’air de marcher, je n’ai pas d’erreurs. Ici, si je reviens sur ma machine locale, si je regarde « tail -f », le fichier « /var/log/messages », j’ai des messages qui sont locaux à ma machine mais j’ai également les messages de la machine « deb8 », on le voit, c’est le nom de cette machine distante, qui arrivent. Donc là, c’est ma machine locale qui vient d’envoyer des logs dans mon fichier « messages ». Ici, si je fais un Ctrl + C, je vais faire un « logger -p user.info », donc je fais un message d’info et le message que je peux afficher c’est : « Message depuis la machine distante ». Et si jamais je fais ça, voilà, j’appuie sur Entrée, je peux venir voir ici. Le message apparait bien dans les logs de ma machine locale. Ça fonctionne en UDP, tout fonctionne très bien, ça veut dire qu’à partir de ce moment-là, les messages qui sont reçus par le syslog de ma machine distante, qui correspondent à une gravité « info » ou supérieure sont envoyés au syslog local. Et le syslog local va à nouveau les filtrer, c'est-à-dire que comme ce sont des messages de la catégorie « info » ou supérieure, là en l’occurrence, il les envoie dans le fichier « /var/log/messages ». Mais je pourrais les envoyer ailleurs, je pourrais ne choisir que les messages qui contiennent une erreur, etc. etc. Je peux retrouver mon filtrage local. De la même manière je pourrais, à distance, ne pas envoyer tous les messages de la catégorie « info » ou supérieure mais tous les messages qui contiennent le mot-clé « error » dedans. Comment est-ce que je ferais ça ? C’est dans mon « vi », « rsyslog.conf ». Si je descends, c’est ici, au lieu de mettre « * .info », je pourrais mettre à la place, donc je fais « i » pour insérer, « :msg » pour dire que c’est par rapport au contenu du message, « contains, » et puis la chaine de caractères sous « contains », ça peut être la chaine de caractères « err », comme « error ». Et à partir de ce moment-là, ce sera uniquement les messages qui contiennent le mot-clé « error » qui seront envoyés à ma machine locale. Donc Échap, « :w », « :q », je fais « systemctl restart rsyslog ». Je regarde si dans les logs je n’ai pas de message d’erreur. Je n’ai pas de messages d’erreur. Donc ça devrait le faire. Je reviens à ma machine locale. Je viens de le redémarrer. Est-ce que celui-là contient la chaine de caractères « err » ? Je ne l’ai pas mais je pense qu’il a été redémarré avant. Maintenant, je vais rester sur celle-là et à distance, je vais utiliser « logger –p user.info » et je vais marquer « un beau message d erreur ». Et si je reviens sur ma machine locale, mon message d’erreur a bien été reçu de la part de la machine deb8. Vous voyez que je ne reçois pas tous les messages, comme ce qui se passait tout à l’heure. Je n’ai pas eu notamment ici les messages me disant : « attention, rsyslog a redémarré, attention, tel problème. » Je n’ai pas reçu ces messages-là. Je n’ai reçu que le message qui correspond au motif que j’ai donné. Pour faire la même chose en UDP, du côté de la machine locale : « /etc/rsyslog.conf ». Au lieu de mettre ici les modules UDP, je vais les recommenter et je décommente les modules TCP. C’est tout ce qu’il y a à faire ici, rien d’autre. Et sur la machine distante, dans le fichier de configuration, « /etc/rsyslog.conf », si je descends, je vais arriver à mes règles, au lieu de mettre « @10.0.2.4 » qui veut dire qu’on envoie en UDP, je mets tout simplement un @@. Le fait de mettre un @@, ça veut dire que le message est envoyé en TCP mais pas en UPD. Pour le reste, le fonctionnement reste le même.

## Créer des journaux système
Donc avec syslog, on a pu remplir les logs correspondants à notre machine, éventuellement à notre réseau, en ramenant sur une machine les logs importants d'autres machines. C'est bien d'avoir des logs, si je vais regarder dans le répertoire « /var/log », effectivement j'ai plein de fichiers de logs qui sont tous intéressants, qui vont contenir tous des informations qui vont d'une part me donner des alertes sur le fonctionnement du système, des informations sur ce qui se passe sur le système et éventuellement des messages me prévenant que quelque chose d'anormal va se passer. Je peux avoir ce genre de choses-là par exemple quand on a le SMART qui est le mécanisme qui est dans les disques durs et qui permet de remonter des statistiques. Le SMART peut remonter des statistiques alarmantes, quand à l’état de santé des disques durs. Dans ce cas-là, je vais dans les logs, avoir des informations me prévenant que j’ai un disque dur qui est un petit peu en train de partir dans les choux et qu’il va falloir songer à le changer. Tout ça, c’est très bien sauf que quand est-ce qu’on va les regarder, les logs ? Les logs, souvent ce qui se passe, c’est qu’on va les regarder à postériori, c'est-à-dire après qu’on ait eu un incident. On a un programme qui a planté, on va regarder dans les logs. On a le disque dur qui ne marche plus, on va regarder dans les logs. Ce qui est dommage parce que dans les logs on avait peut-être des messages qui, si on était allé les voir, nous auraient permis d’anticiper un problème. Alors du coup, il faut aller regarder les logs. Si je fais un « less » de « messages », ici, j’ai plein de messages qui sont là. Mais il n’y a pas grand-chose qui se passe. J’appuie sur Espace, voilà, il y a de temps en temps des messages. Et là, c’est pas une machine qui est très chargée, on fait pas beaucoup de choses dessus. Mais du coup, regarder les logs, c’est quelque chose qui peut être long, on va louper des choses. Ce n’est vraiment pas un travail intéressant. Et puis là, les logs, il n’y en a pas beaucoup. On peut facilement avec quelques machines, avoir des milliers, des dizaines de milliers de lignes de logs à analyser. L’idée, c’est de déléguer ce travail-là à la machine. Il existe des programmes qui vont être capables de m’extraire des informations pertinentes des logs. L’outil qu’on rencontre le plus souvent, il y en a plein d’autres mais l’outil qu’en tout cas moi, j’utilise le plus souvent, c’est un outil qui s’appelle logwatch. Logwatch ne doit pas être installé sur cette machine. Si j’essaie logwatch, effectivement, il n’est pas installé sur cette machine. Je suis sur une machine qui est un CentOS. Donc je vais installer logwatch : « yum -y install logwatch ». Et ce qui va se passer, c’est que du coup, je vais avoir le logiciel logwatch d’installé sur ma machine. Voilà, j’ai logwatch d’installé sur ma machine. Je fais un Ctrl + L pour effacer la page. Logwatch, qu’est-ce que c’est ? Logwatch contient un ensemble de choses qui va regarder le contenu des logs par défaut de la veille et me faire un rapport sur justement ces différentes actions. La commande logwatch commence ici. Quand je lance logwatch, il me dit quand est-ce que j’ai lancé l’analyse, quelle période est couverte par l’analyse, là c’est la journée d’hier. J’ai laissé tous les paramètres par défaut, je n’ai vraiment absolument rien personnalisé. Et la sortie se fait à l’écran, au format « text », ça peut se faire par mail, ça peut se faire en HTML, il y a beaucoup de choses qui peuvent se faire. Et derrière, je vais avoir un détail sur différentes activités. Donc j’ai des choses concernant « cron ». J’ai, en termes de connexion, différentes connexions qui ont eu lieu, l’utilisateur « gdm » est arrivé deux fois. Sur Postfix, Postfix a démarré, c’est le serveur de mail. Il y a eu des connexions qui ont eu lieu pour l’utilisateur Apache, c’est moi qui fait ça, j’ai différentes choses qui apparaissent concernant toujours cette authentification. Je vais aller descendre. J’ai des informations sur les disques durs. J’ai le redémarrage de SSH. J’ai les personnes qui ont lancé la commande « Sudo ». Et on voit que chaque partie est encadrée par un titre. Ici « Begin », c’est le début de tout ce qui va concerner « Sudo » et « End » qui va terminer tout ce qui concerne « Sudo ». Tous les paquets qui ont été installés sur la machine. Ça c’est l’activité que j’ai faite, moi. Et derrière, la gestion de l’espace : combien est-ce que j’ai d’espace disponible ? Combien est-ce que j’ai d’espace utilisé, partition par partition ? Donc je peux tout à fait utiliser mon logwatch pour récupérer tous les matins, un mail dans ma boite aux lettres, me synthétisant l’activité de la machine durant la veille. Alors, c’est asynchrone, c'est-à-dire que j’aurais un rapport sur ce qui s’est passé la veille. Mais je pourrais avoir une vision globale de ce qui se passe sur ma machine avec ça. Ce que je vais faire, pour le faire par mail, c’est que je vais aller éditer le fichier de configuration. Pour cela, je vais aller éditer le fichier « /etc/logwatch/conf/ ». Ce n’est pas un « cd » qu’il faut que je fasse, c’est pour ça que je n’y arrive pas, voilà. « vi /etc/logwatch/conf/logwatch.conf ». Je vais éditer ce fichier-là, le fichier est vide. En réalité, la configuration de logwatch est dans un fichier qui se situe dans le répertoire « /usr/share/logwatch/default.conf /logwatch.conf ». Ce qui va se passer, c’est que quand logwatch va démarrer, il va lire ce fichier-là, il va prendre les directives qui sont dans ce fichier-là et il va ensuite lire le fichier dans lequel je suis là, qui va permettre de compléter ou de remplacer des éléments qui sont dans le fichier qui est dans « /usr ». Donc là, je pourrais mettre simplement les directives que je souhaite changer. Personnellement, je ne trouve pas ça pratique. Je pourrais mettre les directives que je voudrais changer mais son architecture ne me plait pas car je ne vois pas à quoi ressemble la configuration. Du coup, je vais devoir tricher en incluant dans le fichier le fichier qui est dans le répertoire « /usr ». Pour ça, qu’est-ce que je fais ? Je vais faire « :r » pour lire le contenu d’un fichier et c’est ce fichier-là, « /usr/share/logwatch/default.conf /logwatch.conf » que je vais venir insérer dans le fichier « /etc/logwatch/conf/logwatch.conf ». Là, si j’appuie sur Entrée, il m’ajoute le contenu du fichier que j’ai lu. Là du coup, j’ai toutes les directives et je vais pouvoir personnaliser celles que je souhaite avoir. Donc là, j’ai l’output qui me dit qu’actuellement, c’est « stdout » qui est utilisé en output. Le « stdout », c’est quoi ? C’est la sortie standard, ça veut dire que c’est le terminal depuis lequel on va lancer la commande logwatch. À la place, je peux mettre « mail ». Pour cela, je vais sur le « stdout », je fais « c: » pour « change word » et je tape « mail », Échap. Donc à partir de maintenant, c’est le mail qui va être utilisé pour afficher le résultat de la commande logwatch. Au niveau du format, je peux laisser le format « text ». Je peux mettre en HTML. « Mailto », c’est le nom d’utilisateur qui va être utilisé. Là, vous pouvez mettre votre adresse mail : « toto@toto.com », ça devrait fonctionner. Et derrière, c’est de qui provient le mail. Et après, il y a différentes informations qui vont permettre de personnaliser le comportement de logwatch. L’objectif, ce n’est pas qu’on rentre dans les détails, il y a beaucoup de choses qu’on pourrait faire mais là, ça va quand même permettre d’avoir une idée sur qu’est-ce qui va être utilisé. Et à partir de ce moment-là, si je fais « :w », « :q », si je retape la commande logwatch, il va travailler, il analyse les logs d’hier toujours. Mais cette fois, il ne m’affiche rien à l’écran. Tout simplement, il a envoyé un mail à l’utilisateur « root ». J’ai reçu un mail. Avec la commande mail, je peux voir le mail qui est donné à l’utilisateur « root » et qui va contenir la même chose que ce qu’on avait vu précédemment. Ça, par contre ça contient exactement la même chose puisque le résultat de l’analyse est le même. Donc logwatch est vraiment un outil qu’on doit installer sur les machines et si on ne fait rien, si je le laisse tourner tel quel, toutes les nuits, aux alentours de six heures du matin, il y a une analyse qui va être faite et un mail qui va m’être envoyé. Et ça va être envoyé à l’aide de quoi ? Ça va être envoyé à l’aide de « cron » qu’on verra tout à l’heure.

## Comprendre la synchronisation de l'heure
On va s’intéresser maintenant à la synchronisation temporelle. Et on va s’intéresser à la synchronisation des horloges entre différentes machines. C’est quelque chose d’extrêmement important à mettre en place et à avoir tout simplement parce que si je prends l’exemple de ce qu’on vient de faire, c'est-à-dire que l’on vient d’envoyer des logs provenant d’une machine, ici ma machine Debian, vers une autre machine, ma machine locale, qui est une CentOS, j’ai envoyé le log d’une machine vers une autre machine. Les logs, ce sont des éléments qui sont horodatés. À partir du moment où on va manipuler des éléments qui sont horodatés entre deux machines, j’ai intérêt à ce que les heures qui vont être données pour ces messages-là, soient les mêmes sur les deux machines. Imaginons que si je vais voir dans les logs, « /var/log/messages » de ma machine locale qui est ici, je vais rechercher, voilà, des éléments qui correspondent à la machine deb8 qui est la deuxième machine, j’ai des opérations, des messages qui sont horodatées à un moment donné. Ici, 31 mars, 11 heures 19 minutes 22 secondes et j’ai ce message-là. Si jamais ce message-là, je me dis : « ça, ce n’est pas normal, il faudra que je creuse un petit peu mais ce ne sont pas des logs que j’ai envoyés sur ma machine locale. Je vais aller voir sur ma machine distante ces logs-là. » Et que sur ma machine distante, ce n’est pas 11 heures 19 minutes 22 secondes mais c’est 11 heures 22 minutes 14 secondes. Je risque de passer pas mal de temps à essayer de retrouver où ça se trouve, tout simplement parce que les logs peuvent être très nombreux et sur une durée, même si je tourne quelques minutes autour de mon heure supposée, il peut y avoir beaucoup de messages. Donc pour la corrélation des opérations, pour retrouver des opérations, je vais avoir besoin que mes deux machines soient à la même heure. Ça, c’est la première chose. La deuxième chose, il y a d’autres raisons pour lesquelles on va pouvoir faire ça. Ces autres raisons, c’est par exemple à partir du moment où je vais utiliser des partages de fichiers. Si jamais j’ai un répertoire qui est partagé entre les deux machines, j’ai intérêt à ce que les deux machines soient à l’heure pour que quand je modifie ou quand j’écris un fichier, les dates de modification du fichier ne soient pas des dates dans le futur pour l’autre machine, ce qui peut poser des problèmes. Et puis, il y a plein d’autres raisons qui sont des raisons plus organisationnelles ou légales même. Dans certains cas, il y a un certain nombre d’informations qu’on doit légalement enregistrer de façon horodatée. Et si je ne les enregistre pas de façon horodatée, je ne respecte pas mes engagements, je ne respecte pas les obligations légales qu’on me demande. J’ai intérêt à ce que l’horodatage soit correct. Alors, pour aller un petit peu plus loin là-dessus, on va regarder deux choses. On va tout d’abord regarder comment est-ce que l’heure est gérée sur la machine d’une part et d’autre part, comment est-ce qu’on va se synchroniser sur une horloge de référence ? Alors, qu’est-ce que l’heure ? Pour ça, je vais aller sur une horloge de référence. Voilà, maintenant je suis sur une horloge de référence, je suis sur le site web du Bureau International des Poids et Mesures qui est l’heure de référence qui est donnée au niveau mondial. Qu’est-ce qu’on a ? On a ici dans le bandeau jaune, alors c’est un petit applet Flash, qui est affiché ici, cet applet Flash, qu’est-ce qu’elle va me donner ? Elle va me donner l’heure, la date UTC et l’heure UTC. En plus de l’heure UTC, elle me donne le délai nécessaire à la transmission de l’heure sur ma machine locale. Ça veut dire qu’ici, actuellement il est 12 heures 4 minutes et 5 secondes à 9 centièmes de seconde près, c'est-à-dire qu’il faut 9 centièmes de seconde pour que le serveur du Bureau International des Poids et Mesures me transmette son heure. C’est une heure qui est très importante, l’heure UTC, puisque c’est l’heure de référence au niveau mondial. Et elle est donnée par une horloge atomique et surtout, cette heure UTC ne varie pas, ni en fonction de la période de l’année, donc il n’y a pas d’heure d’été, d’heure d’hiver pour l’heure UTC, c’est toujours la même et elle ne varie pas en fonction de la position, l’heure UTC n’est pas liée au fuseau horaire. Justement, les fuseaux horaires sont calculés en fonction de l'heure UTC. Donc c’est notre horloge de référence. Ça, c’est la première chose à bien comprendre. La deuxième chose à bien comprendre également, c’est que si je vais voir sur mon Linux, je suis retourné sur mon Linux, si je tape la commande « date », il me donne une date et une heure qui n’est absolument pas la même que celle que je viens de voir sur le Bureau International des Poids et Mesures. Là moi, j’ai quoi ? Il est 14 heures 05 alors qu’il était midi 05 sur l’horloge du Bureau International des Poids et Mesures. C’est tout simplement parce qu’ici, ce n’est pas l’heure UTC qui est affichée, c’est l’heure locale. C’est l’heure locale, ici c’est le « Common European Standard Time ». C’est l’heure européenne classique. Comment est-ce qu’elle est calculée cette heure-là ? Elle est calculée à partir de mon fuseau horaire auquel on applique les changements d’heure d’été et d’heure d’hiver. Ça, c’est la première chose à bien savoir, c'est-à-dire que si j’ai des machines qui sont disséminées partout dans le monde, les heures, à l’aide de la commande « date », risquent d’être affichées en fonction de l’heure locale et en tenant compte des décalages été et hiver. Si jamais je veux qu’elles soient toutes basées sur la même référence, j’afficherai l’heure au format UTC puisque ma machine, l’horloge interne de la machine, enregistre l’heure au format UTC. Elle applique juste un décalage quand j’appelle la commande « date » pour afficher mon heure locale. Ça, c’est la première chose. La seconde chose, c’est : suis-je sûr que cette horloge-là, suis-je sûr que ma machine est bien à l’heure, qu’elle n’a pas 2, 3 secondes de décalage, qu’elle n’a pas un quart d’heure de décalage ? Pour m’assurer de ça, il y a un protocole réseau qui existe, qui est le protocole NTP. Alors, le protocole NTP, qu’est-ce que c’est ? Le protocole NTP, c’est le protocole de l’heure réseau. C’est le « Network Time Protocol ». C’est un protocole dont, justement, le boulot va être de s’assurer que toutes les machines sont à la même heure. Comment ça fonctionne ? On va avoir un client NTP sur notre machine, on va avoir un petit programme qui va aller se connecter sur un serveur de temps et qui va synchroniser l’heure locale à l’heure du serveur de temps. Voilà un petit schéma qui résume le fonctionnement. Ici, je vais avoir mes machines. Ici, ma machine va être à ce niveau trois, c'est-à-dire c’est ce qu’on appelle un stratum trois, c'est-à-dire qu’elle va recevoir l’heure de la part d’une horloge qui est au stratum deux. Alors le stratum deux, ça va être quoi ? Ça va être des serveurs de temps qui se synchronisent sur des serveurs de temps qui sont de stratum un, on remonte à eux. Et les serveurs de stratum un synchronisent leur horloge avec des horloges atomiques. Ça me permet d’avoir une heure de référence qui est distribuée à des serveurs et ces serveurs servent pour pouvoir donner l’heure aux machines. C’est comme ça que ça va fonctionner. Et dans le protocole, on prend en compte le temps que met la demande vers le serveur pour venir changer l’heure, c'est-à-dire que mon serveur, mon client, mon petit programme sur ma machine va interroger un serveur pour lui demander l'heure. Le serveur va dire : « il est telle heure ». Ça, ça va mettre un certain temps à se faire. Ce temps là il est mesuré pour que l’heure de la machine cliente soit la plus proche possible de l’heure atomique originale. On va mettre ça en place sur nos machines.

## Synchroniser l'heure
Alors maintenant qu’on comprend ce que c’est que l’heure, qu’on comprend l’importance d’avoir plusieurs machines qui vont être à la même heure, on va synchroniser l’horloge de nos machines. Pour ça, on va utiliser un client du protocole « Network Time Protocol ». Alors si je regarde sur ma machine, j’ai un serveur et un client qui sont présents et il va tout simplement suffire que je démarre le client. Pour ça, je peux faire « systemctl status ntpd ». Là, je vais avoir quoi ? C’est le service « Network Time Service », c’est le serveur de temps qui est là. Donc là, c’est un serveur de temps, actuellement il est arrêté mais que j’ai installé sur la machine. Et j’ai également un client qui s’appelle « chronyd », voilà, mais qui n’est pas démarré. « Chronyd », c’est la machine qui va mettre à l’heure mon horloge. Alors même si « Chronyd » est assez intéressant à utiliser puisqu’il est capable de mettre à l’heure la machine même si elle a un gros décalage temporel, avant, je vais utiliser la commande « ntpdate ». Alors, cette commande « ntpdate », elle, avant que je lance « chronyd » qui va essayer de garder la synchronisation, je vais m’assurer que ma machine est bien à l’heure parce que le problème qu’on a avec certains clients de temps, c’est que si le décalage entre l’heure officielle et l’heure locale de la machine est trop important, il n’appliquera pas de lui-même la différence pour remettre la machine à l’heure. Il va se dire : « le décalage est trop important, c’est peut-être quelque chose de volontaire. » Donc il ne fera pas cette synchronisation alors que la commande « ntpdate » va faire cette synchronisation. Pour ça, je vais appeler la commande « ntpdate » et derrière la commande « ntpdate », je vais pouvoir lui donner le nom d’un serveur sur lequel je vais me synchroniser et typiquement, si on fait « pool.ntp.org », il va synchroniser sur un serveur de temps qui a cette adresse IP là. Il y en a pleins, ceux-là sont disponibles pour qu’on puisse les utiliser et pour qu’on puisse se mettre à l’heure, voilà. Là, qu’est-ce qu’il a fait ? Il a dit : « je me suis ajusté au serveur qui a l’adresse IP 45.79.1.70. » C’est une des adresses IP de ce serveur-là. Et le décalage que j’avais, il était de quelques millièmes de secondes. En fait, ma machine était déjà à l’heure. Une fois que j’ai fait ça, ma machine est à l’heure. Maintenant, le boulot suivant, c’est de la garder à l’heure parce que, que ce soit au niveau des quartz qui sont dans les machines, il y a des dérives qui ont lieu, ils ne sont pas totalement précis, surtout si on laisse marcher les machines pendant des semaines et des mois. Petit à petit, le décalage de l’horloge qui est dans la machine et la machine elle-même, ça va se décaler. C’est le premier décalage qu’on va avoir. Le deuxième décalage qu’on va avoir, c’est que là en plus, je suis avec une machine virtuelle et les machines virtuelles ne voient pas passer le temps de la même manière qu'une machine physique, c'est-à-dire que l’hyper-viseur va de temps en temps ne pas envoyer d’information à la machine virtuelle pour ne pas consommer de ressources et elle ne voit pas passer le temps normalement. Il y a d’autres mécanismes qui rentrent en ligne de compte pour les machines virtuelles, pour éviter trop de décalage mais un ordinateur va se décaler dans le temps. Qu’est-ce que je vais faire ? Je vais appeler la commande « systemctl start chronyd ». Je vais démarrer mon client que j’avais vu tout à l’heure. Donc là, voilà, il est démarré. Si j’appelle le « status » pour voir s’il a bien démarré, là voilà, il a démarré et lui, pour le moment il a démarré, il a fait une mesure. Et la fréquence est de 499,909 à plus ou moins 158 parties pour mille lues de la part d’un fichier qui va régulièrement enregistrer les décalages qu’on a. Il fait des statistiques et essaie de s’adapter avec ça en vérifiant l’horloge sur un serveur de référence. Donc une fois qu’on a mis ça en place, notre machine-là, cette machine-là, à partir de maintenant, elle va en permanence garder l’heure correcte. Et donc je pourrais, du coup, être sûr que cette machine-là est à l’heure. Si je fais la même chose sur une autre machine, les deux machines, non seulement seront à la même heure mais en plus seront synchrones entre elles puisqu’elles se synchronisent sur la même horloge ou sur la même famille d’horloge. Et on aura une synchronisation correcte entre les deux, ce qui va me permettre quand je modifie un fichier sur l’un, la date de modification sera la même sur les deux machines si jamais j’ai un partage de fichiers entre les deux. C’est ce qu’il faut mettre en place. C’est vraiment un point qui est super-important à mettre en place. Mettez en place des synchronisations temporelles, mettez en place vos clients NTP pour que vos machines soient à l’heure. C’est un point très important. Quand vous commencez à creuser dans les logs et que vous faites des corrélations entre ce qui se passe sur deux machines, je peux vous garantir que si les machines ne sont pas à l’heure, c’est un véritable cauchemar de pouvoir voir ces différentes corrélations. Voilà, on a mis notre machine à l’heure. On est tranquille de ce côté-là.

## Ordonner le système avec cron
Quand on a une machine qui fonctionne, dans cette machine-là il y a des tâches d’administration qui ont lieu de manière automatisée d’ailleurs, régulièrement. Quel genre de tâches ? Dans les tâches qui ont lieu, il va y avoir la rotation des logs faite par un outil qui s’appelle logrotate, il va y avoir par exemple l’analyse des logs avec logwatch, il peut y avoir le redémarrage d’un certain nombre de services, il peut y avoir la ré-indexation des fichiers du système, il peut y avoir la ré-indexation des pages du manuel, il peut y avoir beaucoup de choses qui ont lieu régulièrement. On va un petit peu creuser ça mais ce sont des opérations qui ont lieu de façon automatique, on n’a pas besoin explicitement de les mettre en place, elles ont lieu. Mais comment est-ce qu’elles ont lieu ? Elles ont lieu parce qu’on a sur la machine un daemon qui tourne, qui s’appelle cron. Voilà, je regarde : « ps -ef », j’affiche tous les processus et j’envoie le résultat de cette commande-là à la commande grep qui m’affichera que les lignes du résultat de cette commande-là, qui contiennent la chaine de caractères « cron ». Et là, je vois que j’ai un processus qui tourne, qui s’appelle crond. Ce processus-là va avoir plusieurs fonctions. Il va avoir une fonction pour les utilisateurs, de pouvoir déclencher certains éléments, certains scripts à certains moments de façon régulière d’une part et d’autre part pour le système, de lancer ces différentes tâches d’administration, ces opérations régulières. Alors, on va dans un premier cas, nous intéresser aux opérations qui sont réalisées au niveau du système. Au niveau du système, si je vais regarder dans le répertoire « /etc/ », si je regarde, j’ai différents... donc « ls -d » pour ne pas les voir dans les répertoires parce que ces répertoires, je vais les passer en paramètre, « cron.* », tout ce qui est en « cron. » quelque chose, voilà. J’ai ces répertoires-là qui existent. Et là, les répertoires qui vont m’intéresser ce sont surtout ceux-là. C’est surtout le « cron.daily », « cron.hourly », « cron.monthly » et « cron.weekly ». À quoi ils correspondent ? Dans les opérations qui ont lieu, on a vu par exemple que logwatch, c’était bien de le faire tourner tous les jours puisqu’il analysait les logs de la journée de la veille. Du coup, je vais vouloir lancer l’analyse des logs une fois par jour. Je ne saurais pas exactement quand dans la journée mais une fois par jour. Du coup, si je vais me placer dans le répertoire « cron.daily », voilà, je suis dans le répertoire « /etc/cron.daily », j’ai un certain nombre de fichiers qui sont présents. Et ces fichiers correspondent à des scripts qui seront exécutés sur la machine de façon quotidienne. Donc tous les jours, ces scripts-là seront exécutés. Le système en général les exécute tôt le matin, entre trois et sept heures du matin, très souvent. Et comme ça, quand on arrive au boulot, quand on vient devant la machine, les opérations de maintenance ont déjà été réalisées. Alors là, on peut regarder les opérations qu’il réalise. Ici, il y a un petit zéro devant, c’est pour être sûr que le nom vient avant les autres et il sera réalisé en premier, c’est logwatch. Donc première étape, qui a lieu de façon quotidienne, c’est l’analyse des logs. Ensuite, une fois qu’on a fait l’analyse des logs, il y a un script qui s’appelle logrotate, qui est appelé. Ce script logrotate, c’est un script qui fait appel à un programme qui est dans le système, qui va effectuer une rotation des logs. Une rotation des logs, c’est qu’on ne va pas garder des logs qui vont grossir ad vitam aeternam. Ce qu’on va faire, c’est qu’on va voir nos logs et régulièrement, on va renommer le fichier et puis on va garder un certain nombre de fichiers archivés. Ça me permet de garder suffisamment longtemps le log pour le besoin que je peux avoir et ça me permet d’éviter de conserver une quantité astronomique de logs qui vont finir par remplir mon disque dur. Le script suivant, « man-db.cron », qu’est-ce qu’il va faire lui ? Il va réindexer les pages du manuel. Alors à quoi ça correspond ? C’est que quand on fait une recherche par mot-clé au niveau du manuel, par exemple si je fais « man -k calendrier », je ne sais pas ce qu’il va me sortir mais voilà, il m’affiche toutes les pages du manuel qui contiennent le mot-clé « calendrier ». Et par conséquent, il a besoin d’indexer toutes les pages du manuel qui sont installées sur le système pour pouvoir après faire cette recherche de façon asynchrone. Là, quand j’ai fait mon « man -k », il n’est pas allé voir sur toutes les pages du manuel qui était installé quelles étaient celles qui contenaient le mot-clé « calendrier ». Non, il a mis ça dans une base de données. C’est effectué tous les jours, ce qui fait que quand j’installe une nouvelle page du manuel, dès le lendemain, les mots-clés contenus dans cette page du manuel seront accessibles avec le « man -k ». Et le mlocate sert à indexer tous les fichiers du système. Si jamais je fais un « locate calendar », voilà, il m’affiche tous les fichiers du système qui contiennent le mot « calendar ». Ici, on le voit il est marqué ici. Donc ça veut dire quoi ? Ça veut dire que pour me l’afficher, il a fallu qu’il indexe tous les fichiers de la machine. Donc ça a été fait par cette commande mlocate et c’est fait de façon quotidienne. Donc si jamais vous avez une opération, un script qui doit s’exécuter de façon quotidienne, il suffit de mettre le script dans ce répertoire-là. Ce sont des scripts système hein, ce ne sont pas des scripts pour les utilisateurs. Pour les utilisateurs, on va voir qu’on a d’autres outils pour le faire. Voilà, j’affiche par exemple le logwatch. Tout simplement, il appelle « LOGWATCH_SCRIPT ». « LOGWATCH_SCRIPT », c’est la commande logwatch et éventuellement, il lui met l’option « output mail », il ne lui laisse pas l’option « output stdout » pour afficher le résultat sur la sortie standard puisqu’avec cron, il n’y a pas de sortie standard. La sortie standard, c’est le terminal. Ici, il n’y a rien qui est connecté sur le terminal, ça a lieu en tâche de fond. Ça a lieu le matin, pas besoin d’être connecté pour que ça ait lieu, c’est le système qui va lancer ces différentes commandes-là. Donc il suffit de mettre le programme là-dedans, dans ce répertoire-là, pour qu’automatiquement il soit lancé. Alors, on peut aller jeter un petit coup d’œil sur les autres. Je fais Ctrl + L pour effacer la page, « ls -d cron.* », qu’est-ce que j’ai ? Donc ça c’était « .daily », je peux faire un « ls » de « cron.hourly » pour voir ce qui se passe toutes les heures. Il lance un outil qui s’appelle anacron. C’est un outil qui va m’assurer que si ma machine est éteinte, les tâches qui auraient dû avoir lieu pendant que ma machine était éteinte, elles auront quand même lieu. Parce que par exemple, si je dis : « l’indexation des pages du manuel va se faire tous les matins à trois heures du matin. » Très bien, seulement il est 20 heures, j’ai fini de travailler, j’éteins ma machine. Il est neuf heures, je viens au boulot, j’allume ma machine. Du coup, elle n’a pas eu lieu. Anacron, son boulot, c’est de voir : est-ce qu’il y a eu des tâches qui auraient dû être lancées à un moment donné et qui n’ont pas pu être lancées parce que la machine était arrêtée ? Si oui, il va les lancer, il va les reprogrammer, c’est le boulot de « anacron ». Toutes les heures on va regarder s’il n’y a pas de tâches qui sont passées à l’as et qui ont besoin d’être reprogrammées. Si je fais un « ls cron.monthly », c’est ce qui a lieu tous les mois. Là, il n’y a rien qui a lieu tous les mois. C’est une installation de base que j’ai faite de ma machine. Il n’y a pas grand-chose de particulièrement complexe dedans. C’est vraiment une installation de base. Et si je fais le « ls cron.weekly », il n’y a rien non plus. Là, on voit que tout ce qui a besoin d’être réalisé par le système et j’insiste sur le « par le système », il suffit d’avoir un script qui le réalise et qu’on place ce script-là dans le répertoire adéquat pour être sûr que l’opération a bien lieu régulièrement dans le système. Après, je n’ai même plus besoin de m’en préoccuper, ça a lieu de façon automatique, c’est cron qui va gérer ça tout seul comme un grand.

## Mettre en place des tâches régulières
Alors la crontab système, elle est super pratique pour tout ce qui va concerner, ben le système, justement. Mais elle va pas du tout être adaptée dans le cas où un utilisateur va vouloir réaliser des opérations de façon régulière, tout simplement que il faut être root pour aller écrire dans ce répertoire /etc/cron.quelque chose, donc du coup ça ne sera adapté vraiment que pour le système. Pour les utilisateurs, on a ce qu'on va appeler la crontab. La crontab, c'est le tableau de cron, utilisateur par utilisateur. Si je fais un ls -l de /etc/cron.* , alors je mets ls -d, si je mets pas le d, le ls m'affiche le contenu des répertoires, quand il y a des répertoires passés en paramètres, là, je veux pas afficher le contenu des répertoires, je veux afficher le nom des fichiers et des répertoires, c'est pas leur contenu, si j'avais pas mis de -d, il m'aurait affiché le contenu de cron.daily, ce qui est pas ce que je voulais. Donc là, je vois, j'ai donc les crontab système, j'ai affiché en plus quel fichier /etc/cron.deny. Ce fichier-là, c'est le fichier qui va me donner la liste des utilisateurs à qui l'on interdit de mettre en place une crontab personnelle. Ici, si je regarde son contenu, donc cron.deny, il n'y a rien dedans, ça veut dire que tous les utilisateurs de mon système auront le droit de mettre en place une crontab qui leur est personnelle. Tous les utilisateurs du système pourront programmer des tâches qui vont s'exécuter de façon régulière dans la machine, donc c'est là où on va mettre les limitations. Comment est-ce qu'on va programmer ça ? Eh bien pour ça, je vais me déconnecter de l'utilisateur root, je vais me connecter en tant que l'utilisateur yves. Voilà, je me déconnecte de l'utilisateur root, je vais faire Ctrl+L pour effacer la page. id, qui je suis, je suis bien l'utilisateur yves, et, donc je n'ai pas de droit particulier sur la machine. Si je veux regarder actuellement quelles sont les tâches que j'ai programmé dans ma crontab, je vais faire crontab -l pour lister les tâches de ma crontab. Et on voit que j'ai pas de crontab, donc il n'y a rien de programmé pour yves. C'est l'occasion de mettre quelque chose, donc je vais faire quoi ? Je vais faire contab -e pour mettre en place ma crontab. Donc là, qu'est-ce qui se passe ? Là, il m'affiche un fichier vide, en réalité, il me lance vi sur un fichier vide. Là, il va me demander que j'écrive la crontab que je veux réaliser. Alors la crontab, elle a une syntaxe qui est assez particulière et à laquelle il va falloir faire très attention parce qu'il y a quelques pièges derrière. La syntaxe, ça va être la suivante : Je fais i pour insérer des caractères, je vais mettre un # pour le commenter, pour éviter que ce soit interprété, mais j'ai différentes colonnes dans mon fichier qui vont être séparées par des blancs, des espaces ou des tabulations. La première colonne va concerner les minutes. La deuxième colonne, les heures, la colonne d'après, ça va être le jour, la quatrième colonne, donc on a la première min heures jour, ça va être le mois de l'année, et la dernière colonne, ça va être le jour, mais cette fois de la semaine. jourdelasemaine, j'attache tout histoire qu'on le voit bien, et la dernière colonne contient, la tâche à réaliser, la commandeàexécuter. Donc j'ai une première commande qui est les minutes, les heures, le jour, le mois, le jour de la semaine, et la commande à exécuter. Et donc, qu'est-ce que veulent dire ces commandes-là ? Toutes les minutes, crontab va regarder les minutes courantes tout d'abord, et il va regarder si dans la crontab de mon utilisateur, les minutes courantes correspondent aux minutes que j'aurais mises ici. Si oui, il va regarder si l'heure courante correspond à l'heure qui est donnée dans la crontab. Si ça correspond, il va regarder celui-là, il va regarder celui-là, il va regarder celui-là, et si j'ai une correspondance au niveau du jour de la semaine, au niveau du mois, au niveau du jour du mois, au niveau de l'heure et au niveau des minutes, alors il va exécuter la commande. Si jamais je mets une ligne dans laquelle on va avoir 2 5 1 1 1 par exemple, et puis là, je mets /usr/local/bin/script1 par exemple, voilà, script1.sh, il va exécuter la commande /usr/local/bin/script1.sh quand ? Tous les lundis, le 1 c'est lundi, 0 c'est dimanche, 1 c'est lundi, 2 c'est mardi, jusqu'à 7 dimanche à nouveau. Quand on sera au mois de janvier, on sera le premier janvier, et qui sera 5 heures et 2 minutes. Donc là, ça, ça va lancer la commande, je vais le marquer derrière histoire qu'on le voit pour que ce soit illustré, le script sera lancé tous les lundis 1er janvier à 5h02, voilà ce que veut dire cette première ligne-là. L'objectif de la crontab c'est de pouvoir préciser quand est-ce qu'on va exécuter régulièrement nos commandes. Pour aller un petit peu plus loin, et pour illustrer le piège qui vous attend, parce que tout le monde se fait avoir au début, si je mets 5**** , et puis que je mets /usr/local/bin/script2.sh, quand est-ce que script2.sh va s'exécuter ? Alors je vous laisse 5 secondes pour que vous y réfléchissiez, et puis on va voir si vous avez eu raison ou pas. Si vous voulez un petit peu plus de temps, je vous conseille de mettre la vidéo en pause, mais la question que je vous pose, c'est donc quand est-ce que ce script2 va s'exécuter. Ben il va s'exécuter toutes les heures, et il va pas s'exécuter toutes les cinq minutes. Pourquoi est-ce qu'il va s'exécuter toutes les heures ? Eh bien tout simplement parce que ici, qu'est-ce que j'ai dit ? J'ai dit que les minutes devaient être à cinq quand il va s'exécuter, elles devaient être à * , donc c'est quelle que soit l'heure, quel que soit le jour du mois, quel que soit le mois de l'année, quel que soit le jour de la semaine. Et quand est-ce qu'on a les heures qui sont à cinq minutes ? Eh ben ça a lieu à minuit cinq, puis la fois d'après, ça a lieu à une heure cinq, puis la fois d'après ça a lieu à deux heures cinq, trois heures cinq, quatre heures cinq, etc. Cette commande-là, elle aura lieu toutes les heures à l'heure H plus cinq minutes. Donc faites attention, parce que c'est vraiment un piège très classique, on se fait quasiment tous avoir au début, cette ligne-là, le script n'est pas exécuté toutes les cinq minutes, il est exécuté toutes les heures à l'heure H plus cinq minutes. Alors du coup, si je veux exécuter un script toutes les cinq minutes, il va suffire que je marque toutes les cinq minutes ici, j'ai plusieurs façons de le faire. La façon la plus casse-pieds à faire, c'est de marquer 0,5,10,15,20, etc., je vais pas toutes les marquer, puis après, je mets ****, et puis le nom de mon script /usr/local/bin/script3.sh. Alors là, il va s'exécuter toutes les cinq minutes pour les vingt premières minutes. Il faudrait que j'aille jusqu'à 60, vous avez vu que c'est quand même un petit peu long à écrire. J'ai une autre alternative qui va être toutes les minutes, en fait ce ne sera pas toutes les minutes, ce sera par incréments de cinq minutes. Donc toutes les minutes par incréments de cinq minutes c'est toutes les cinq minutes, quelle que soit l'heure, quelle que soit le jour du mois, quel que soit le mois de l'année, quel que soit le jour de l'année, /usr/local/bin/script4.sh, ben le script4, lui, va bien s'exécuter toutes les cinq minutes, c'est comme ça qu'on ferait s'exécuter un script toutes les cinq minutes. Voilà un petit peu comment cette crontab elle va fonctionner, donc là, si jamais je fais Echap :w, donc j'enregistre, :q, lui , qu'est-ce qu'il va faire, il va vérifier si la syntaxe est correcte, et si la syntaxe est correcte, il l'installe dans le système. Et cette fois, si je rappelle ma commande crontab -l, il m'affiche la crontab que je viens de créer. Faites très attention, si vous voulez l'éditer, si vous faites un crontab -r, et le r se trouve à coté du e, qu'est-ce qui va se passer ? Le -r il ne fait pas rien, le r c'est comme remove, il a détruit la crontab. Donc faites très très attention quand vous le tapez, soyez prudent, si jamais vous appuyez entre deux touches, vous prenez le risque de tout effacer. Donc voilà pour la crontab des utilisateurs.

## Lancer des tâches ponctuelles
Alors la commande cron, c'est une commande qui est formidable quand on veut lancer différentes tâches de façon régulière c'est-à-dire régulière et cyclique, à une fréquence qu'on aura établie, cette fréquence était donnée en élément temporaire : tous les lundis, tous les premiers du mois, une fois par an, tous les 1er janvier etc. Quelques fois, ça ne correspond pas à notre besoin et quelques fois on va vouloir plutôt lancer une tâche de façon ponctuelle. On la lance une fois mais pas tout de suite. On veut la lancer dans 2h, demain, à une date précise mais une fois lancée, on n'a pas besoin de la répéter. Donc cron dans ce cas-là n'est absolument pas adaptée, à la place on va plutôt utiliser la commande at. Ici, je tape la commande at. at n'est pas content car je ne lui ai pas dit quand j'allai lancer ma commande donc il dit que l'heure à laquelle je veux la lancer n'est pas la bonne mais c'est pour vous donner cette commande at qui veut dire à tel moment, dans ce contexte. Et par exemple, je pourrais dire que at 9:30 pm Sunday, c'est à 9h30 du soir dimanche et là j'ai un prompt qui apparaît. Donc derrière la commande at, on va pouvoir préciser quand est-ce qu'on souhaite lancer la tâche que l'on souhaite exécuter. Là je l'exécute à 9h30 de l'après-midi un dimanche et puis je peux taper les commandes que je souhaite exécuter dimanche à 9h30. "echo bonjour" que je redirige dans le fichier /tmp/ dimanche-21-30. Là je vais dire que j'ai fini d'entrer mes directives, les différentes commandes que je veux exécuter dimanche à 21h30. Je vais faire Ctrl+D. Là j'ai un premier job, c'est comme ça que ça s'appelle. J'ai une première tâche qui a été programmée. Donc elle aura lieu dimanche 2 avril à 21h30. Il y a plusieurs manières de dire à quelle heure on veut réaliser les opérations. On peut faire comme ça, je peux également faire at 22:30 Sunday, il va l'accepter. Je vais faire echo bonjour encore /tmp/dimanche-22-30, donc ce n'est pas la même heure. Ctrl+D et là effectivement à 22h30 il va s'exécuter. Je peux donner la notation anglo-saxonne, je peux donner la notation sur 24h mais j'ai également la possibilité de programmer des tâches non pas à une heure donnée mais je peux programmer des tâches après une période par rapport à maintenant. Je peux tout à fait dire at now, le mot anglais pour maintenant, +10 mn. Et là qu'est-ce que je vais faire ? Je lance une autre opération, je fais des petits echo parce que ça va être facile à voir. "dans 10 mn", je redirige ça dans le fichier /tmp/test_ de_at. Je fais Ctrl+D quand j'ai fini mon opération. Et là si je regarde quelle heure il est maintenant. Il est 15h40 et à 15h50, cette commande-là va s'exécuter. Donc ce qui est important de bien comprendre avec cette commande at, c'est que la tâche s'exécutera qu'une seule fois. Et je vais pouvoir préciser quand est-ce qu'elle s'exécute de différentes manières. Je peux même aller très loin. Puisque je peux dedans donner des dates qui vont s'exécuter dans très longtemps. Je peux tout à fait donner une information disant at now +10 years. Dans 10 ans, j'exécuterai la tache que je vais décrire ici "echo je suis vieux " dans /tmp/plusvieuxdedixans, Ctrl+D. Et quand j'ai ça, cette tâche est programmée et va s'exécuter dans 10 ans. Là j'ai programmé plein de tâches avec différentes syntaxes. Dans la page de manuel de at on a différentes syntaxes qu'on peut utiliser mais là on a un petit aperçu du comment de le faire. Évidemment, on peut mettre dans 1h, dans 10 mn, dans 1 jour, 1 semaine, 1 mois, 1 an, 3 semaines, etc. On peut préciser, donner une date. Là je disais 22h30 dimanche et je peux donner la date. Je vous laisse allez regarder le format dans la page du manuel. Mais le problème c'est que j'ai plein de tâches qui sont programmées. Comment je vais pouvoir d'une part voir les tâches programmées, puisque c'est utilisateur par utilisateur, et d'autre part comment je peux supprimer une tâche que j'ai programmée, que finalement je n'ai pas besoin d'exécuter ? Pour ça, j'ai la commance atq qui va m'afficher la file d'attente de toutes les tâches qui ont été programmées. Là je sais que j'ai celle-là qui a été programmée, c'est la tâche n°1, la première tâche qui avait lieu et puis la dernière c'est celle-là. C'est celle dans 10 ans, on voit c'est en 2027 qu'elle va s'exécuter. C'est l'utilisateur Yves qui va les exécuter et je n'ai pas le détail mais je sais que ces tâches-là elles sont programmées. Si jamais je souhaite supprimer la dernière par exemple, la 4. Dans 10 ans finalement je n'ai pas besoin d'écrire ça. Je vais utiliser la commande atrm et je vais donner le numéro de la tâche. C'est pour ça que je dois faire atq avant pour connaître le numéro de la tâche. Donc je fais atrm 4. Il me dit plus rien mais si je rappelle mon atq, q comme la queue, je n'ai plus la tâche n°4.

## Afficher les processus
Dans ma machine, il y a des processus qui vont tourner. Les processus correspondent aux programmes qui sont en train de s'exécuter dans la mémoire de l'ordinateur. C'est le rôle du noyau, la finalité de la machine, c'est d'avoir des programmes qui fonctionnent, mais qui tournent dans la mémoire. J'ai donc différentes commandes que j'ai déjà utilisées mais on va revenir dessus, on va creuser un petit peu ça, des commandes qui vont me permettre de visualiser les différents processus qui sont en cours d'utilisation. Tout d'abord, la commande PS, elle veut dire « Process », elle va m'afficher des processus mais juste quelques uns. Lesquels va-t-elle m'afficher ? Les processus associés à mon utilisateur, l'utilisateur Yves et associés au terminal sur lequel je suis connecté. Donc là, il y a le processus PS car il s'exécute et le processus Bash qui correspond au « shell » qui est là. Si je lui passe l'option « -f », il va m'afficher la filiation des processus. Qu'est-ce que c'est ? C'est que chaque processus est lancé à partir d'un autre processus. Il n'y a que le tout premier, « systemed-unit », qui est lancé par le noyau, tous les autres sont lancés depuis un processus déjà présent dans la machine. Qu'est-ce que je vais voir ? Que mon processus Bash, son numéro de processus, qu'on appelle le PID, c'est le numéro 34/14. Et le processus Bash a été lancé par un processus qui a comme numéro 34/09. C'est comme ça qu'on va lire ces différentes informations, le PPID, c'est le « parent PID », le numéro du processus qui a lancé celui-là. Qu'est-ce que je vais voir en faisant un « ps-f » ? Il a comme processus le 27.389 et son processus parent, c'est le 3.314, sept processus Bash. C'est normal car j'ai tapé le PS alors que j'étais mon « shell » qui est le Bash. Donc, cette hiérarchie de processus, on la retrouve bien à l'aide de la commande PS. Maintenant, je n'ai que les deux processus de mon terminal. Qu'est-ce qui se passe si je voulais avoir les processus de l'ensemble de la machine. Je vais rappeler ma commande PS et je vais rajouter un petit e, je peux le rajouter après ou avant, dans un autre tiret, tout va fonctionner. Je fais très souvent, par habitude : « ps-ef » et il m'affiche tous les processus de la machine. Je vais donc retrouver les mêmes informations qu'on avait, c'est-à-dire le propriétaire du processus, le numéro du processus, le numéro du processus parent et différentes informations. Dans les informations, c'est quand est-ce que le processus a été lancé et sur quel terminal. Ici, quand j'ai un point d'interrogation, c'est un processus qui n'a pas été lancé depuis un terminal, il n'a donc pas été lancé par un utilisateur, il est donc non-interactif. Soit c'est un processus qui va gérer des choses à l'écran sur l'interface graphique avec X Windows, comme le cas de Firefox. Il n'est pas lancé depuis un terminal, je n'ai pas tapé Firefox dans un terminal, j'ai cliqué sur l'icône. Soit il s'agit d'un srt de noyau comme on peut voir ici, car il y a des crochets de chaque côté, soit il s'agit d'un daemon, comme on peut voir ici.

## Interpréter les informations de la commande top
Si je veux surveiller sur ces processus, la consommation qu'ils vont faire, au niveau des ressources de la machine, j'ai la commande Top que beaucoup de gens connaissent, donc, pour cette commande Top, on va s'intéresser à quelles informations vont m'être données par la machine. Quelles informations va t-on avoir ? Tout d'abord, on va avoir l'information qui est l'heure : 15h56. Elle se met à jour toutes les trois secondes, et donc, toutes les trois secondes, l'heure va augmenter. La machine est en marche, elle est « up » depuis une journée, quatre heures et 45 minutes. Donc, ça fait un jour, quatre heures et 45 minutes que la machine n'a pas été redémarrée. Si je la redémarre, je vais retomber à quelques secondes, puis, évidemment, ça va augmenter petit à petit. Il y a trois utilisateurs connectés sur la machine. En réalité, j'ai deux terminaux qui sont connectés sur la machine, j'ai celui-là et une autre fenêtre connectée. Tout cela est connecté via l'interface graphique, ça fait bien trois connections. J'ai la charge moyenne. La charge moyenne, c'est quoi ? Je vais revenir dessus dans un instant, car on peut se poser la question : « Qu'est-ce que la charge moyenne ? » J'ai ici le nombre de tâches qui est le nombre de processus directement dans la mémoire. Mais sur ces 163 processus qui sont dans la mémoire, il n'y en a qu'un seul qui est dans l'état « running », qui est en train de s'exécuter. Et en l'occurrence, je peux le voir ici, plus bas, dans la colonne S, celui qui sera en R, c'est celui qui s'exécute, donc, là, je l'ai loupé, voilà, c'est le top qui est en train de s'exécuter. Et, du coup, j'en ai 162 qui sont en train de dormir. Dormir, cela veut dire que pour le moment, il se met charge en mémoire, mais ils n'ont pas d'activité à réaliser dans le processeur. Ils attendent d'avoir besoin de faire une activité. Aucun d'entre eux n'a été arrêté, Arrêter, c'est un processus que l'on a suspendu, on le laisse en mémoire, mais on lui interdit d'accéder au processeur. C'est-à-dire, que du coup, il est figé dans son état en mémoire. Et le zombie ? C'est un état transitoire d'un processus, donc, le zombie correspond juste à un état de processus. Et c'est un état normal dans lequel trouvent tous les processus, à un moment donné quand ils vont s'arrêter. En réalité, on a vu en faisant le « ps-ef », je le refais, il y avait hiérarchie de processus, le processus 51/52 a lancé le 51/60, si jamais ce processus 51/60 s'arrête, il va prévenir son pair qu'il s'est arrêté. Il s'arrête, en réalité, il libère la mémoire, il prévient son pair qu'il s'est arrêté, il attend que celui-ci dise Ok et il disparaît. Qu'est-ce qu'il se passe si le pair est occupé à ce moment-là et qu'il ne peut pas lui répondre ? Alors, le processus 51/60 se sera arrêté, aura libéré sa mémoire, aura dit à son pair qu'il s'était arrêté et voilà ! Il est toujours présent dans la liste des processus parce que son pair n'a pas répondu et tant qu'il ne le fait pas et qu'il s'est arrêté et a libéré la mémoire, il est dans l'état zombie. Donc, c'est un état transitoire, on ne peut pas le tuer, c'est un zombie car on ne peut ni le tuer ni l'arrêter parce qu'il est déjà arrêté, il a libéré sa mémoire, il est juste encore présent dans la liste de processus. Et si son pair a planté, il va rester comme ça dans la liste des processus, mais, ça n'aura pas d'impact énorme sur la consommation de mémoire, sur le CPU puisque de toute façon, il est déjà mort, il a déjà libéré ses ressources, donc, il est tout simplement en train d'attendre que son pair lui dise : « Ok, j'ai vu que tu t'étais arrêté. » Si je reprends mon Top, je vois que j'ai un pourcentage CPU, c'est tout simplement, la répartition de l'activité actuelle. C'est un pourcentage, si on fait la somme, on doit obtenir à peu près 100, il peut parfois y avoir des arrondis malencontreux, mais ici, par exemple, j'ai 3% de l'activité du CPU pendant les 3 secondes qui se sont passées de mise à jour du Top, qui ont été allouées à l'espace utilisateur. L'espace utilisateur est là où j'exécute les processus. Et là, j'ai eu 0,3% qui ont été alloués à l'espace Noyau, xy, c'est l'espace Noyau, qui est toutes les opérations qui vont être réalisées par le noyau, vous vous en doutez, mais également, toutes les opérations qu'un processus va demander à réaliser à un « driver ». Quand je dois lire des données sur le disque dur, le processus ne le fait pas, il va demander au noyau d'appeler le « driver » pour lire les données sur le disque dur. La consommation de ressource de la lecture des données sur le disque dur va avoir lieu dans cette partie-là, puisque c'est dans l'espace Noyau. Le NY, c'est le « Nyce », donc, je vais le passer, ce n'est pas le plus important, par contre, le ID « idle » est important, c'est le pourcentage de temps que le processeur a passé à ne rien faire. C'est 98% ! En tout cas, on peut voir qu'il y a une activité très faible sur la machine. WA, c'est pour les attentes d'entrée et de sortie de disque, et ça, ça concerne les interruptions et ça, la virtualisation. Et derrière, on a la consommation mémoire, attention, c'est également un piège, il faut faire attention à ne pas tirer de mauvaises conclusions de cette consommation mémoire. Quelles mauvaises conclusions pourrait-on tirer ? C'est qu'ici, j'ai 1 G de mémoire et que je n'ai que 122 M disponibles. Je vais peut-être me dire que ce n'est pas beaucoup et lui rajouter de la mémoire. La mémoire qui est en « free », c'est de la mémoire qui ne sert à rien, elle est alimentée électriquement, elle n'est allouée à aucune tâche. Tant qu'il y a de la mémoire, le noyau Linux va tenter de l'utiliser. Il va l'utiliser pour faire tourner des processus, certes, mais il va également l'utiliser pour faire des « buffer » d'entrée-sortie, pour mémoriser des données, etc. Tant qu'il y a de la mémoire disponible, il va tenter de l'utiliser au maximum pour exploiter au mieux la machine. Et ensuite, on a la liste des différents processus classés par consommation CPU. Si jamais, je veux les classer par consommation mémoire, je fais un M majuscule et je vois effectivement que Firefox est un gros gourmand qui occupe 47% de la mémoire de ma machine. Et si je veux quitter le Top, il suffit que j'appuie sur la touche Q.

## Arrêter et démarrer un processus
Alors, tous ces processus qui tournent dans la machine qui représentent des programmes en cours d'exécution, à un moment donné, ils ont été démarrés. Soit ils ont été démarrés par « systemd » lors du boot de la machine ou avec la commande « systemctl » quand il s'agit de [inaudible], on a vu ça dans la première partie de cette formation, soit ils ont été lancés par un utilisateur. Simplement, quand je tape vi ici, ça va me créer un processus VI qui va s'exécuter dans la mémoire de la machine. Et quand je vais faire « :q », le processus va s'arrêter. Maintenant, je vais me poser d'autres questions. C'est que là, mon processus vi, je peux le démarrer, il est interactif. Je peux travailler dessus. Qu'est-ce qu'il se passe si je veux l'arrêter sans être en interaction avec lui ? Je peux avoir la même problématique si jamais je fais un « ps-ef », que je fais derrière un « grep firefox ». J'ai un Firefox qui tourne. Il n'est pas à l'écran. Il est derrière, mais je ne veux pas l'amener en premier plan. Je vais le laisser tourner derrière, dans la fenêtre Firefox. Et pourtant, j'aimerais bien pouvoir l'arrêter, et proprement. Comment je vais faire ? Pour faire cette action, dans nos systèmes, on a des outils qui permettent d'envoyer des signaux aux différents processus. Donc, je vais envoyer un signal à mon processus Firefox, lui demandant de s'arrêter. Alors, attention avec cette commande qui envoie des signaux. Elle est extrêmement mal nommée, parce qu'elle s'appelle commande « kill ». Elle ne va pas tuer de processus, elle va envoyer un signal à un processus. Quel signal ? Si je fais un « kill-l », il va me lister les différents signaux qui sont possibles d'être envoyé au processus. Et celui qui va m'intéresser en premier lieu, c'est le processus SIGTERM. Ce processus SIGTERM, qu'est-ce qu'il va faire ? Il va envoyer un signal demandant au processus de s'arrêter. Comment je vais faire ça ? Je vais faire un « kill ». Soit je fais un -15 parce que le numéro du SIGTERM c'est 15. Mais ce que je peux faire aussi, c'est faire un -TERM ou -SIGTERM. Il trouvera le bon numéro pour lui. Et derrière la commande « kill », je vais marquer le numéro du processus auquel je souhaite envoyer le message. Voilà, je fais « kill-TERM ». J'appuie sur Entrée. Mon processus Firefox a reçu une demande lui demandant : « Est-ce que tu peux t'arrêter s'il te plaît ? ». Si je refais ma commande ps, je n'ai plus de Firefox dans la mémoire. Et j'ai arrêté mon Firefox proprement, comme si j'étais allé dans le menu et fais Quitter. Ça, pour arrêter un processus, c'est la première façon de faire. Si jamais il ne réagit pas à cette manière-là, il y a une deuxième manière de faire qui est l'équivalent de faire un Ctrl+C. L'équivalent du Ctrl+C, c'est le signal SIGINT. INT comme « interrupt », on va interrompre le processus. Donc, évidemment, on va faire un « kill-INT » du processus. Et s'il ne veut toujours pas s'arrêter, à ce moment-là, on pourra peut-être se poser la question si on lui envoie un SIGKILL. Le SIGKILL, il est méchant. Qu'est-ce qu'il va faire ? Il ne va pas demander l'avis au processus. C'est le noyau qui transmet les signaux. Là, en gros, quand j'utilise la commande « kill », ma commande « kill », ici, elle envoie un signal au noyau qui retransmet le signal au processus. C'est le noyau qui est au cœur de tout ça. Au lieu de directement dire au processus : « Arrête-toi s'il te plaît », si j'envoie le « kill-9 », donc le SIGKILL, le noyau, au lieu de relayer le signal, va directement supprimer le processus de la mémoire, sans rien envoyer au processus, sans rien dire au processus. Alors, ça ne fonctionnerait qu'avec les processus dont je suis propriétaire, ou si je suis « root », ça marchera pour tous les processus. Mais le problème d'utiliser le SIGKILL, c'est qu'on va supprimer de la mémoire un processus en cours de fonctionnement et on ne va pas regarder s'il a bien désalloué toute la consommation, les ressources qu'il avait allouées et qu'il consommait. S'il a ouvert des fichiers qui commençaient à écrire des données dans des fichiers, il va arrêter là où il en était. Il va pas les fermer proprement. Il peut y avoir des données manquantes, ça peut les corrompre. Donc le SIGKILL, il est à utiliser vraiment en dernier recours. Alors, je vais encore une fois relancer mon Firefox. Mais cette fois, en ligne de commande parce que ça va un peu changer les choses. Si je lance mon Firefox en ligne de commande, il va s’exécuter. Voilà, je reviens à mon terminal. J'ai mon Firefox qui s'exécute en tâche de fond. Maintenant que Firefox s'exécute en tâche de fond, je voudrais reprendre la main sur ma ligne de commande. Pour ça, je peux faire un Ctrl+Z, il va suspendre l'exécution du processus et je vais pouvoir continuer à travailler. Seulement là, mon processus Firefox est stoppé. Il n'a plus accès au CPU, donc il ne peut plus afficher de page web. Ce qui dommage, je voudrais quand même qu'il puisse accéder aux pages web. Pour ça, en faisant fg, « foreground », je peux ramener mon processus en avant-plan. Mais je n'ai plus accès à mon « shell », donc, peut-être que la bonne opération, ce serait de faire bg, comme « background », arrière-plan. Et si jamais je fais bg, mon processus, voyez qu'il a rajouté une esperluette. Le processus Firefox est passé en arrière-plan. Le processus Firefox fonctionne. Tout va bien, mais moi, j'ai toujours récupéré la main, ici, et je peux continuer à travailler. Si jamais mon processus Firefox veut afficher des messages sur le terminal, il affichera les messages à l'endroit où se trouve le curseur. Ça pourra polluer ma sortie, mais ça ne va pas gêner les autres processus qui accèdent au terminal. Et de cette manière-là, j'ai deux processus qui tournent en parallèle. Le vi, si je le lance, par exemple. Le vi et le Firefox sont attachés, pour l'instant, tous les deux, au terminal. S'ils affichent quelque chose sur leur sortie standard, ça va s'afficher, ici, sur le terminal. Alors, c'est extrêmement pratique de faire ça. Moi, je l'utilise beaucoup, par exemple, quand j'utilise un fichier avec vi. J'édite un fichier et je veux aller vérifier quelque chose pour continuer l'édition du fichier. Je ne vais pas quitter mon vi, je fais un Ctrl+Z et ça suspend l'utilisation du vi. Donc, j'ai accès à ma ligne de commande, je fais ma vérification. J'ai vérifié ce que je voulais. Je veux ramener mon vi en avant-plan. Je fais fg comme « foreground ». Je le ramène en avant-plan. J'ai pas eu besoin d'enregistrer ce que je faisais, de faire d'autres opérations. Tout ce que j'ai fait, c'est suspendre l'exécution du vim et j'ai repris, en avant-plan, l'exécution du vim. Là je vais faire « Echap, :q! » pour pouvoir quitter vi sans enregistrer ce que j'ai changé. Donc là, c'est différentes manières que l'on a pour communiquer avec nos processus, de les arrêter proprement, de les lancer et de récupérer la main sur le terminal. Pour mon Firefox, au lieu du Ctrl+Z, j'aurais pu directement rajouter l'esperluette, Firefox &. Ça l'aurait directement lancé en tâche de fond.

## Contrôler les processus avec lsof
Sur tous les processus qui tournent sur ma machine, je vais avoir un certain nombre d'outils qui vont me permettre de les gérer, de voir par exemple la consommation qu'ils vont faire, on a vu les commandes « top », « ps » qui permet de les lister et j'ai une commande absolument magique qui s'appelle la commande « lsof » qui va me permettre d'explorer ce qu'est en train de faire le processus. Cette commande « lsof », elle existe sur la plupart des Unix. Si elle n'est pas installée, vous pouvez le faire et elle va avoir comme objectif d'aller visualiser les fichiers ouverts. Le nom peut être trompeur parce que fichier ouvert : « ls openfile » c'est ce que ça veut dire, les fichiers représentent tout ce qui est présent dans la machine. Ça va beaucoup plus loin que tout simplement les fichiers classiques. Je vais commencer en me posant la question mon fichier « /var/log/messages » : quels sont les processus qui ont ouvert ce fichier, que ce soit en lecture ou en écriture ? C'est la commande « lsof » qui me permet de répondre à cette question. Si je fais ça, j'ai un message qui est dû à l'interface graphique qui est utilisée ici mais si je fais ça, je vais voir que le « /var/log/messages » est ouvert en lecture « FD » car j'ai un petit « r » ici par le processus « abrt-watch », alors, il me manque la fin, et c'est le processus numéro 517. C'est étrange car je pensais que le « rsyslog » l'aurait ouvert, peut-être que ce n'est pas le cas, peut-être que mon « rsyslog » ne tourne pas, je vais en profiter pour le regarder. « systemctl status rsyslog » pourtant il est ouvert mais il n'est pas en train d'écrire dedans, je ne sais pas pourquoi, il ne l'a pas ouvert en écriture. Ça doit être dans la configuration que j'ai changée tout à l'heure. Donc là, j'ai le processus 517 qu'il a ouvert. Si je regarde par contre mon processus « rsyslog » qui a comme numéro le 22.162 cette fois je peux me poser la question inverse : quels sont les fichiers ouverts par ce processus 22.162 ? Ce n'est pas à partir du fichier que je trouve le processus mais c'est à partir du processus que je vais regarder quels sont fichiers qui ont été ouverts. Je peux à nouveau faire cela avec cette commande « lsof » « lsof -p » comme processus suivi du numéro du processus et là, il m'en affiche toute une tripotée. Si je remonte un peu, je vais remonter là, que vais-je avoir comme informations ? Ici, il m'affiche le nom de la commande, c'est la commande « rsyslogd », son numéro de processus et l'utilisateur qui l'a lancé. Je vais aller relativement vite car il y a beaucoup de choses que l'on pourrait dire là dessus, mais pour vous compreniez les fondamentaux de cette commande « lsof ». Dans la colonne « FD », j'ai de quelle manière il l'a ouvert la manière « cwd » qui veut dire « current working directory » le répertoire de travail et cela veut dire que le répertoire « / » est celui dans lequel se trouve le processus. Si le processus regardait quels étaient les fichiers présents dans son répertoire, il verrait les répertoires de « / » Le deuxième, le « rtd » c'est : quel est le répertoire « / » pour le processus ? Là, il correspond au répertoire « / » du système. Sans m’appesantir là dessus, sans parler pendant des heures, ça correspond à une valeur différente quand le processus est lancé dans un environnement « ch root » Ensuite, le « FD » « txt », ce n'est pas du texte, le « FD » « txt » va m'indiquer le fichier qui a été utilisé et qui contient les données binaires qui sont exécutées dans la mémoire de la machine. C'est le fichier exécutable. Là, c'est le fichier « /usr/sbin/rsyslogd » Ensuite, j'ai plein d'entrée « mem », toutes ces entrées, à part les deux premières qui sont liées à systemd, toutes les autres correspondent à des fichiers « .so » qui sont dans le répertoire « /usr/lib64 » Toutes ces entrées-là correspondent à des bibliothèques partagées, ce sont les « dlf » qu'on a sous Windows par exemple, c'est la même idée, le même fonctionnement qui ont été chargés par « rsyslogd » pour pouvoir fonctionner. Tous ces fichiers-là sont des bibliothèques partagées que « rsyslogd » utilise. Ensuite, on en a trois intéressants ici d'une part « 0r » « 1w » « 2w » Le « 0r » correspond à l'entrée standard habituellement connectée au clavier, sauf que « rsyslogd » n'est pas attaché à un terminal. Comme il n'y est pas attaché, il n'est pas connecté à un clavier donc son entrée standard, comme on dit, est connectée à rien du tout donc « /dev/null » Le « 1w » correspond à la sortie standard quand je lance la commande « ls » le résultat s'affiche à l'écran, ça passe par la sortie standard et encore une fois, c'est un « daemon » donc pas attaché au terminal donc ça vaut « /dev/null » et la sortie « 2w » c'est la même chose sauf que ce n'est pas pour la sortie standard, c'est pour la sortie d'erreur, rattachée au terminal, comme il n'y a pas de terminal, c'est « /dev/null ». La sortie « 3 » et la « 4 », on le voit, ce sont des adresses IP où on écoute avec le protocole «UDP » sur le port de « syslog ». Ce port est un numéro affiché ici. Vous ne voyez pas de numéro parce qu'il essaye de bien m'afficher les choses et il a remplacé le numéro par le nom qui y est associé. Si jamais je veux connaître le numéro, il faut que je fasse un « grep syslog » dans le fichier « /etc/services » Il a vu un numéro, typiquement, c'est 514 et il l'a remplacé par « syslog » parce que dans le répertoire « /etc/services » on lui a dit en « udp 514 » c'est « syslog ». Si jamais je fais ça, voilà : 514 en « udp », il a mis le nom « syslog», voilà. C'est tout simplement ça. J'écoute en « IPv4v», en «IPv6 » Ici, il y a « eventpoll » et « inotify » c'est un mécanisme dans le noyau qui va me permettre de déclencher des événements quand il va se passer des opérations. Ensuite j'ai la liste des fichiers, qui va communiquer avec « systemd ». Ensuite, j'ai 8,1 8,1 8,1 qui sont des fichiers qui sont ouverts en « w » donc en écriture. J'ai donc la liste des fichiers ouverts en écriture. Je n'arrivais pas lire mon fichier « /var/log/messages » tout simplement parce qu'il a été effacé et à partir de ce moment-là « rsyslog » n'a pas été relancé donc il est resté connecté sur l'ancien. Ça doit être dans les manipulations que j'ai réalisées pendant la journée. Voilà, on a vraiment la liste de tous les fichiers qui ont été ouverts, que ce soit en lecture, en bibliothèque partagée ou au niveau réseau, du processus. C'est donc vraiment une commande très intéressante et puisqu'elle arrive à lire des données au niveau du réseau, je vais même en profiter pour vous afficher le résultat de la commande : « lsof -i » qui va m'afficher, non pas ce qui a été ouvert pour un processus donné ou un fichier donné mais tout ce qui va concerner le réseau I comme « Inet » ou « Internet » tout ce qui correspond au réseau va être visible dans cette commande-là. Je vois quel processus a ouvert quel numéro de port; avec quel protocole. Cette commande « lsof » est vraiment une commande extrêmement importante à connaître puisqu'elle va vous permettre de savoir quand vous avez lancé des processus quels sont les fichiers ouverts, qu'est-ce qui va manquer, pourquoi il n'arrive pas à faire quelque chose, etc. C'est vraiment une commande à garder sous le coude.

## Surveiller les ressources
Dans cette partie, je vais m'intéresser à la consommation des ressources qu'on va avoir dans les différents processus. On a parlé un peu tout à l'heure de la commande « top », j'ai laissé une commande « top » à l'écran, qui s'exécute parce que ce qui va m'intéresser c'est de voir la valeur de la charge moyenne. J'ai une machine qui est assez chargée, j'ai fait un peu des bêtises avec, tout à l'heure j'ai limite planté la machine parce que je lui ai demandé de faire trop de choses mais pourquoi lui ai-je demandé de faire trop de choses ? Parce que ça se voit au niveau de la charge moyenne, on voit qu'ici j'ai une valeur de 10 et ici une valeur de 8 et ici une valeur de 5. Enfin 8,44 10,53 5,28 La charge moyenne est toujours trois nombres dont le premier représente la charge moyenne durant la dernière minute, le second la charge moyenne durant les cinq dernières minutes c'est donc une moyenne pendant cinq minutes pendant une minute pour le premier, pendant cinq minutes pour le deuxième et une moyenne pendant quinze minutes pour le troisième. Le 5,28 ici est la moyenne de la charge pendant les 15 dernières minutes. Il ne me dit pas ce qu'est cette charge moyenne, ça me donne juste un nombre. Que représente ce nombre ? Pour le comprendre, on va faire une analogie. Quand là j'ai un processus qui s'exécute, il a donc besoin d'accéder au processeur, c'est ce que veut dire qu'un processus s'exécute, il a besoin d'accéder au processeur. Pour accéder au processeur, il va aller se mettre dans une file d'attente. Seulement, il n'y a qu'un seul processeur et là j'ai plusieurs programmes qui fonctionnent. Il va donc y avoir du monde qui va faire la queue devant le processeur comme le samedi après-midi quand on va faire nos courses il y a plusieurs personnes qui attendent devant les caisses. C'est tout à fait le même fonctionnement, la charge moyenne va mesurer la longueur de la file d'attente devant la caisse en prenant en compte la personne en train d'être servie par le caissier ou la caissière. Ici, le fait que j'ai 5,99 veut dire qu'en moyenne durant la dernière minute, j'avais 5,99 processus dans la file d'attente pour accéder au processeur. Il y a donc cinq processus qui veulent accéder au seul processeur présent dans la machine. La charge moyenne ne me donne aucune autre indication que celle-ci. Cela veut dire qu'il ne faut pas tirer d'autres conclusions que celles que je viens de dire : il y a tant de personnes qui attendent. Peut-être que, quand vous allez au supermarché, vous allez préférer une caisse où il y a plus de monde mais où les gens ont moins de produits. Si j'ai acheté une banane ou si j'ai trois caddies pleins quand je vais au supermarché, je vais être compté comme une personne dans la file d'attente. Ici, c'est pareil, j'ai un processus « cc1 » qui est une compilation, j'ai lancé une compilation du noyau en arrière-plan sur un autre terminal, donc c'est un gros boulot qui est effectué là, cette compilation « cc1 » va occuper beaucoup de ressources sur la machine mais dans le calcul de la charge moyenne elle va occuper autant de place que la commande « top » qui ne fait que m'afficher des mesures. Faites attention à ça, la charge moyenne ne veut pas forcément vous dire que la machine est à genoux, elle veut tout simplement vous dire qu'il y a plus ou moins de monde qui attend devant le processeur. C'est tout, rien d'autre. Il ne faut pas en tirer d'autres conclusions. Ici, j'ai une charge qui va tourner aux alentours de 5, ce n'est pas compliqué, on peut faire, plus ou moins, monter la charge de la machine en fonction du type de machine sur lequel on est. Ce que j'ai fait ici, je fais un « Ctrl + C » et j'arrête ma compilation. J'ai fait ma compilation en passant une option « -j 3 » et la commande « make » c'est spécifique à la compilation du noyau mais ça veut dire qu'il va me faire trois files de compilation, il va me compiler trois fichiers différents en parallèle pour pouvoir, si jamais j'ai plusieurs processeurs, occuper tous les processeurs. Ce qui fait que ça ira plus vite si j'avais plusieurs processeurs. Pas de chance, je n'en ai qu'un mais ça m'a fait artificiellement monter la charge de la machine à une valeur supérieure à 3. Il y a 3 pour la compilation mais il y a également le reste de l'activité de la machine. Est-ce que ça aurait fonctionné plus vite ou moins vite que si je fais juste un « make » qui compile et fait un seul processus de compilation ? J'aurai qu'un seul processus «cc ». Est-ce qu'il ira plus vite ou moins vite ? Il ira à la même vitesse puisque, de toute façon, je n'ai qu'un seul processeur. Voilà à quoi correspond cette charge moyenne. Il y a d'autres choses qui sont intéressantes à regarder, qui sont avec la commande « vmstat ». Cette commande va m'afficher des statistiques sur l'ensemble des processus de la machine et, si je regarde une ligne, la ligne va contenir des choses qui peuvent sembler un peu cryptiques mais avec l'explication vous allez voir que c'est très intéressant de l'avoir. Tout d'abord, quand on lance un « vmstat » il est suivi de l'intervalle de mesure. Là je fais une mesure toutes les cinq secondes. La première ligne, on n'en tient pas compte parce que c'est une moyenne depuis le démarrage de la machine. La deuxième ligne est une moyenne durant l'intervalle entre la première et la deuxième ligne donc durant les cinq dernières secondes. J'ai tout d'abord « proc » avec deux colonnes « r » et « b » Le « proc » est le nombre de processus et le « r » me donne le nombre de processus dans l'état « running » qui veut dire en train de s'exécuter dans la file d'attente du processeur, file d'attente du processeur : ici 3, ici 1, ici 2, ici 3, ici 2 etc. « b » ce sont des processus qui sont bloqués, en attente d'entrée/sortie, c'est-à-dire que c'est la même chose qu'au supermarché et que quelqu'un devant vous arrive devant la caissière et vous laisse passer car son mari est allé chercher du lait ou sa femme du jus d'orange donc vous laisse passer le temps qu'il revienne. Ce n'est pas bloquant, un autre processus peut passer devant mais il lui manque quelque chose pour s'exécuter. Pour la partie mémoire, c'est extrêmement compliqué à l'interpréter. En général, je ne le regarde pas. Pour la mémoire, je vais plutôt regarder les colonnes « swap ». « si » et « so » me font savoir si on a utilisé le disque dur pour y mettre des éléments qui étaient dans la mémoire vive ou est-ce qu'on l'a utilisé pour rechercher des éléments qu'on avait précédemment mis sur le disque dur pour les remettre dans la mémoire. En gros, on utilise l'espace de « swap », une partie du disque dur, pour étendre la mémoire. Si on a des valeurs en permanence dans le « si » et le « so » c'est mauvais signe parce que notre machine va ramer et ça va signifier qu'on demande trop de choses à réaliser par rapport à la quantité de mémoire qu'on a dans la machine à cet instant-là. Le « io » c'est le nombre de lectures et d'écritures sur le disque. Le « system », on va avoir... Le « in » et « cs » sont les interruptions le nombre de changements de contexte quand on passe d'un processus à un autre mais surtout, ici, c'est l'activité CPU Si je prends là, j'ai 88% dans l'espace utilisateur 12% en système, 0% en « iddl » et ceux-là sont pour l'occupation de disque, en attente des disques ou pour les machines virtuelles. Ce sont vraiment ces trois là qui vont m'intéresser. Ici, on voit que le processeur ne va pas trop s'ennuyer, il est quasiment toujours à 0% sauf là 1% de temps en temps, autrement il est quasiment à 0% « iddl », à ne rien faire, soit il fait des opérations pour les processus, soit des opérations au niveau des « drivers ». Avec cette commande-là, en quelques instants, je peux identifier si ma machine est un peu juste en termes de CPU, en nombre de processus, bref j'ai une vision de ce qui se passe sur la machine et une vision de la consommation que font mes processus sur les ressources de ma machine.

## Conclure sur les services système Linux
Nous voici arrivés au terme de cette formation sur les services système sous Linux. On a vu beaucoup de choses intéressantes. On a commencé en parlant de « systemd » qui est le logiciel qui va permettre de gérer les services dans la machine, qui va permettre de les gérer lors du démarrage puisque « systemd » va me permettre de choisir quels sont les services que je vais activer dès le boot de la machine mais c'est également lui qui va me permettre d'arrêter un service qui tournait déjà, qui a été activité lors du boot de la machine et que je ne souhaite plus faire tourner, de désactiver un service lors du prochaine boot de la machine ou de démarrer un service de façon ponctuelle, de façon permanente, de recharger des services dont la configuration a été modifiée, bref toutes ces opérations-là vont être réalisées par notre « systemd ». On est ensuite allé voir du côté de la journalisation et on a vu « syslog » et « rsyslog » absolument indispensales à comprendre dans les distributions Linux et on a vu comment on pouvait faire une sélection des messages qui étaient reçus par « syslog » pour en extraire ceux qui nous intéressent et les mettre dans différents fichiers. On a également pu voir comment un service « syslog » pouvait passer par le réseau pour envoyer ses « logs » ou, tout du moins, une sélection de ses « logs » directement à un serveur distant. On a joué le rôle d'un serveur distant donc on a récupéré les données d'une machine qui générait des « logs ». On s'est ensuite intéressé à la gestion du temps et on a vu comment on pouvait s'arranger pour que l'ensemble de nos machines soit à la même heure et que cette heure corresponde à une heure officielle, ce qui peut être extrêmement important dans certaines situations. Ensuite, on s'est intéressé à un service système très important qui est présent sur toutes les distributions Linux qui est « Cron » et on a vu comment « Cron » est capable de me déclencher des tâches d'administration de façon régulière, toutes les heures, tous les jours, toutes les semaines, tous les mois, éventuellement tous les ans, pour le système. On a vu également comment Cron pouvait être utilisé par les utilisateurs pour qu'ils puissent choisir quand lancer certaines opérations, quand : c'est-à-dire tous les premiers lundis du mois, tous les matins à 2h52 ou, éventuellement, toutes les cinq minutes. On a vu également un autre outil qui, lui, ne me permet pas de déclencher régulièrement une tâche mais de déclencher ponctuellement une tâche, c'est la commande « at » et on a vu comment cette commande « at » est capable de me programmer une tâche dans le futur. On a ensuite terminé ces vidéos en explorant quelques commandes concernant les processus. On va vu ce que c'était que la charge de la machine qui correspond en réalité à l'occupation CPU, à la taille de la file d'attente du CPU. On a vu comment la commande «lsof » me permet de voir quel processus accède à quel fichier, comment il y accède quelles sont les bibliothèques utilisées par un processus en cours et on a également exploré la commande « vmstat » pour avoir une vision globale de l'état de ma machine. Voilà, avec toutes ces choses-là, j'espère que vous avez appris plein de nouvelles commandes, que vous avez une meilleure vision de votre système et que cela va vous permettre de mieux exploiter les machines sur lesquelles vous travaillez. En tout cas, moi, j'ai passé un bon moment et je vous dis à très bientôt.










--------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------

##### Résumé


/etc/init.d       fichier qui gére les services



On veut faire quoi avec un service?

  - voir son statut (ex: status ssh)
  - démarrer un service
  - stopper un service
  - lister les services


  => systemd (pour « system daemon » : le démon du système) est un ensemble de programmes destiné à la gestion système, conçu pour le noyau Linux. Il permet le chargement en parallèle des services au démarrage, gère les services et essaie de réduire les appels aux scripts shell. Son but est de remplacer le démon init System V, appelé aussi SysVinit.

        systemd se manipule grâce à la commande             systemctl

        La configuration des services se trouve par défaut dans le répertoire
                            /lib/systemd/system
                            ou
                            /usr/lib/systemd/system

        On utilisera le répertoire /etc/systemd/system pour stocker ses modifications et configurations personnelles, ce qui a le gros avantage que ces fichiers ne seront pas effacés en cas de mise à jour du système.


  => openrc
  rc-status     => permet de voir la liste des services qui sont démarré .
      Avec systemd c'est beaucoup moins lisibles



      avec openrc pour start; stop; restart; reload (ne recharge que le fichier de conf):

              /etc/init.d/nomService start    ex pour ssh:    /etc/init.d/sshd start

      avec systemd:

              systemctl start sshd
